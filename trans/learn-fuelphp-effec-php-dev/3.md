# 第三章建筑

在我们开始使用新安装的 FuelPHP 版本构建任何东西之前，让我们先看看架构的一些主要方面。我们还将介绍一些您应该为项目放置代码的地方，然后在下一章中用示例进行说明。

在本章中，我们将介绍以下主题：

*   环境、常量和配置
*   Apache 配置
*   FuelPHP 引导程序
*   模型、视图和控制器

# 环境、常数和配置

任何开发人员都会告诉您，在实时生产环境中直接编辑文件从来都不是一个好主意。为此，FuelPHP 将环境的概念融入其核心。环境允许在项目生命周期的每个阶段进行不同的配置。FuelPHP 支持以下四种环境设置：

*   `\Fuel::DEVELOPMENT`：这是默认的环境设置，也是您开始的地方
*   `\Fuel::TEST`：您可以在这里使用测试数据运行代码
*   `\Fuel::STAGING`：这是您获得客户批准和接受的地方
*   `\Fuel::PRODUCTION`：这是生活环境

如果未设置环境，代码将以开发模式运行。可以通过多种方式设置环境。

## 服务器和 Apache 配置

本节将教设置环境变量的最简单方法，但前提是您可以访问项目域的 Apache 配置或虚拟主机文件。在配置或虚拟主机文件中，只需包含以下代码：

```
SetEnv FUEL_ENV production
```

### 注

`FUEL_ENV`代码需要大写，因为它是一个 PHP 常量

## 引导 PHP 文件

如果您没有权限设置服务器配置并希望获得它，另一种方法是在应用程序引导中设置环境。这可以在位于`fuel/app/`的`bootstrap.php`文件中使用以下代码完成：

```
Fuel::$env = ( isset( $_SERVER['FUEL_ENV'] )? $_SERVER['FUEL_ENV'] : Fuel::PRODUCTION ;
```

## 配置

一旦您配置了环境，就值得考虑项目的配置。FuelPHP 在自动加载配置时遵循层次结构。这对于数据库设置来说非常方便，这意味着您的生产连接对于生产和登台环境来说更加安全。事实上，团队甚至不需要访问数据库凭据就可以进行项目工作。配置目录结构可以类似于以下代码：

```
app/
    config/
        db.php
        development/
            db.php
        staging/
            db.php
        test/
            bd.php
        production/
            db.php 
```

环境目录中的设置被视为比更高的目录中的设置更重要，提供了具有回退功能的细粒度配置控制。这对于测试和确保每个环境都可以进行不同的配置（例如，第三方 API 连接详细信息）非常有用。

包配置遵循相同的层次结构。在这种情况下，应用程序配置文件夹中的包配置比包目录中的配置更重要。这允许使用`app/config`文件夹中的配置文件覆盖包中的默认选项。

## 常数

在与包的关系中，其文件夹路径的详细信息采用常量的形式。以下是引导文件中设置的 PHP 常量：

*   `APPPATH`：应用程序代码和目录所在的应用程序目录的路径
*   `COREPATH`：核心 FuelPHP 文件的路径
*   `DOCROOT`：资产的公用文件夹和`index.php`文件
*   `PKGPATH`：包目录路径
*   `VENDORPATH`：作曲家根目录的路径

# 模型、视图和控制器

如果不提及**模型-视图-控制器**（**MVC**设计模式，那么架构的任何外观都是不完整的。如果你以前写过 PHP，或者看过其他众多框架中的任何一个，你都会听说 MVC 模式。它允许代码的逻辑分离。控制器处理逻辑，而模型确保数据的一致性，并执行与数据存储的交互。该视图向用户显示控制器和模型的结果。到目前为止，一切顺利；为什么要提到 MVC 模式？FuelPHP 引入了 ViewModel 和一些基类，为您的项目提供了一个良好的开端。

## 视图和视图模型

视图存储在`app`文件夹中的`views`文件夹中，例如`fuel/app/views`。

它们可以在子文件夹中组合在一起，通常与控制器操作直接相关，例如位于`fuel/app/views/user/`中的`login.php`将与`user`控制器中的`login`方法相关。它还有一个类名`user/login`。

还值得注意的是，视图可以使用从控制器或 ViewModel传递给它的变量。他们还可以使用任何核心 FuelPHP 类和本机 PHP 函数。为了帮助将逻辑与表示分离，建议只使用基本的`if`语句和循环。

安全性始终很重要，因此，传递给视图的所有变量都将使用配置的输出过滤器（通常为`Security::htmlentities()`）进行清理。此行为可以在每个控制器内更改或禁用，从配置文件运行的默认函数也可以更改或禁用。

为了减少 FuelPHP 应用程序的内存占用，视图被“延迟加载”。这意味着只有在调用或回显时才会渲染它们。

我们前面提到了 ViewModels；它们充当控制器和视图之间的粘合剂。当应用程序开始变得复杂时，很难决定一段代码是否应该放在控制器或视图中。代码可能与应用程序逻辑关系不大，而与表示逻辑关系更大。这就是 ViewModels 使用的地方。

ViewModels 在用户输入发生后发挥作用。然后，它们检索视图所需的数据。它们不操纵数据，但可以在视图之前与数据存储交互。

## 型号

FuelPHP核心模型（`Model_Crud`包含基本 CRUD（创建、读取、更新和删除）功能，使其能够快速轻松地开始使用数据存储。它只是处理表的快捷方式，不是 ORM 包的一部分。`Model_Crud`和`ORM`包的命名约定相同；这使得更新 ORM 包以实现更复杂的数据交互变得非常容易。ORM 包包括许多高级功能，从软删除到时间历史记录保存。

使用 ORM 包将要求您定义有关数据的更多详细信息，例如数据库表之间的关系。在下一章构建示例应用程序时，我们将讨论其中的一些。

## 控制器

控制器是应用程序中更有趣的部分发生的地方。与项目的其他部分一样，代码在以下文件夹结构中有一个逻辑位置。控制器进入`fuel/app/classes/controller`文件夹。

路由器获取 URL，加载所需的控制器，然后将请求传递给控制器中相应的操作或方法。例如，导航到`http://project.dev/home/index`URL 将调用 home controller 中的`index`方法。控制器的结构如下所示：

```
class Controller_Home extends Controller
{
    public function action_index()
    {
        $data['css'] = Asset::css(array('reset.css','site.css'));
        return Response::forge( View::forge('home/index'));
    }
}
```

### 注

控制器内的动作或方法以动作前缀，这是为了帮助您使用保留的 PHP 方法名称，例如`list`，并且仍然具有控制器方法的逻辑名称。可以创建其他方法，但没有`action_`前缀，只能直接调用，而不能通过 URL 调用。

如果您正在构建一个 API 或设置一个 AJAX 系统，那么可以将这些方法分离出来。在下面的示例中，`action_example`将接受 GET 请求，而 POST 请求将转到`post_example`方法，如下所示：

```
class Controller_Home extends Controller
{
     public action_example(){
       // Add your code here
     }
     public post_example(){
       // Add your code here
     }
}
```

此功能与基本控制器模板一起使用，您可以将其用作创建应用程序时的起点。`action_`和`post_`方法的分离仅适用于混合型或 rest-base 控制器。有四个基本模板：基本模板、模板、rest 和混合模板。

### 模板

模板控制器是前面提到的基础控制器的扩展，它使用预定义的`before()`和`after()`方法内置了模板支持。它可以用于将视图包装在带有页眉和页脚的布局中。您的布局模板应存储在`fuel/app/views/template.php`中。

### 休息

与模板控制器一样，rest 控制器是基本控制器的扩展。它没有内置模板支持操作，而是内置了 RESTful 支持，使构建 API 更加容易。

### 注

如果在 rest 控制器中添加了一个`before()`或路由器方法，则需要调用父方法`parent::before()`才能使其全部工作。

### 杂种

混合控制器将其余控制器和模板控制器结合在一起。

# 总结

在本章中，我们介绍了 FuelPHP 体系结构的一些基本部分。我们已经看到，FuelPHP 为可扩展控制器和模型提供了一个很好的起点。这为大多数项目提供了一个良好的开端，并引入了一些功能，这在任何 PHP 框架中都是第一次；例如，时态 ORM 模型。

在下一章中，我们将开始使用这些知识创建一个演示应用程序。