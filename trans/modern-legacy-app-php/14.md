# 十五、删除页面脚本中的重复逻辑

现在，页面脚本中的逻辑是高度重复的。它们看起来都很相似。每一个都加载一个设置脚本，实例化页面控制器的一系列依赖项，调用该控制器，并发送响应。

我们的前端控制器为我们提供了一个执行每个页面脚本的公共元素并消除重复的地方。一旦删除了重复，我们就可以开始删除页面脚本本身。

# 重复逻辑

本质上，我们的每个页面脚本都遵循以下组织流程：

```php
Generic Page Script
1 <?php
2 // one or more identical setup scripts
3 require 'setup.php';
4
5 // a series of dependencies to build a controller
6 $request = new \Mlaphp\Request($GLOBALS);
7 $response = new \Mlaphp\Response('/path/to/app/views');
8 $controller = new \Controller\PageName($request, $response);
9
10 // invoke the controller and send the response
11 $response = $controller->__invoke();
12 $response->send();
13 ?>
```

因为我们一直致力于始终为控制器对象（`$controller`）使用相同的变量名，始终为调用它使用相同的方法名（`__invoke()`），并且始终为响应（`$response`）使用相同的变量名，所以我们可以看到每个页面脚本中唯一不同的部分是中间部分。该中心块构建控制器对象。前后的一切都是一样的。

此外，因为我们有一个前端控制器来处理所有传入的请求，我们现在有了一个地方来放置每个页面脚本的公共前后逻辑。这就是我们在这里要做的。

## 拆除过程

一般情况下，去除过程如下：

1.  修改前端控制器以添加设置、控制器调用和响应发送。
2.  修改每个页面脚本以删除设置、控制器调用和响应发送。
3.  抽查、提交、推送并通知 QA。

## 修改前控制器

首先，我们修改前端控制器逻辑，以执行每个页面脚本通用的逻辑。我们将其从上一章中列出的代码更改为类似以下内容：

```php
docroot/front.php
1 <?php
2 // page script setup
3 require dirname(__DIR__) . '/includes/setup.php';
4
5 // set up the router
6 $pages_dir = dirname(__DIR__) . '/pages';
7 $router = new \Mlaphp\Router($pages_dir);
8
9 // match against the url path
10 $path = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
11 $route = $router->match($path);
12
13 // require the page script
14 require $route;
15
16 // invoke the controller and send the response
17 $response = $controller->__invoke();
18 $response->send();
19 ?>
```

我们已将需要`Router`类文件的行替换为需要安装脚本的行。（在关于自动加载的章节中，我们将自动加载程序放入了我们的设置脚本中，因此它现在应该为我们自动加载`Router`类。）

在页面脚本中需要文件`$route`之后，我们还添加了两行。它们调用控制器并设置响应。在这个共享逻辑中，我们使用控制器和响应对象的通用变量名。（如果您在页面脚本中选择了除`$controller`和`$response`之外的其他内容，请替换上述脚本中的内容。同样，如果您使用的是除`__invoke()`之外的通用控制器方法，请也替换该内容。）

### 注

请注意，安装工作将特定于我们的遗留应用程序。只要每个页面脚本的设置工作是相同的（此时应该是相同的），将公共设置工作放在这里就可以了。

## 从页面脚本中删除逻辑

现在我们已经添加了设置、控制器调用和向前端控制器发送响应的工作，我们可以从每个页面脚本中删除相同的工作。这样做应该像在`pages/`目录中进行项目范围的搜索并删除找到的行一样简单。

查找安装行可能需要一个正则表达式，因为安装脚本的相对位置可能导致使用相对目录遍历的行。下面的正则表达式将找到`includes/setup.php`、`../includes/setup.php`、`dirname(__DIR__)`。`/includes/setup.php`等：

搜索安装程序：

```php
1 ^\s*(require|require_once|include|include_once) .*includes/setup\.php.*$

```

但是，查找控制器调用和响应发送行不需要正则表达式，因为它们在每个页面脚本中都应该相同。

搜索控制器调用…

```php
1 $response = $controller->__invoke();

```

搜索正在发送的响应…

```php
1 $response->send();

```

在每种情况下，删除找到的行。现在不再需要，因为逻辑已移动到前控制器。

## 抽查、提交、推送、通知 QA

一旦重复的页面脚本逻辑被删除，取而代之的是放置在前端控制器中的相同逻辑，我们就可以抽查应用程序。我们通过运行特性测试（如果存在）来实现，或者通过浏览或以其他方式调用应用程序中的每个页面（如果不存在）。

在确定应用程序仍然正常工作后，我们提交新代码并将其推送到公共存储库。然后我们通知 QA 我们有新的工作要他们审查。

## 常见问题

### 如果设置工作不一致怎么办？

在本书的示例中，我们只展示了一个脚本，为每个页面脚本执行设置工作。某些旧版应用程序可能使用多个安装脚本。只要每个页面脚本的设置工作是相同的，即使它由多个脚本组成，我们也可以将所有设置工作移动到前端控制器。

但是，如果每个页面脚本的设置工作不完全相同，则我们需要处理一个问题。如果此时页面脚本没有使用相同的设置过程，那么在继续之前，我们应该尽可能解决这个问题。

我们必须使所有页面脚本中的设置工作完全相同。这可能意味着在前端控制器中包含来自所有页面脚本的所有不同设置工作，即使某些脚本不需要所有这些设置工作。如有必要，我们可以在下一章中纠正这种重叠。

如果我们不能执行相同的单阶段设置过程，我们可能必须执行双阶段或两阶段设置过程。首先，我们将常见的设置工作整合到前端控制器中，并将其从页面脚本中删除。无关的、特殊情况的或特定于页面的设置工作可以作为依赖项创建工作的一部分保留在页面脚本中。

### 如果我们使用不一致的命名怎么办？

在前几章中，本书强调了一致命名的重要性。这一章是这种一致性得到回报的关键。

如果我们发现我们在控制器对象变量和/或控制器方法名称的命名上不一致，那么一切都不会丢失。我们将无法进行一次性搜索和替换，但我们仍然可以手动完成每个页面脚本，并将名称更改为一致。然后，前端控制器可以使用新的一致名称。

# 回顾和下一步

通过这一步，我们将页面脚本简化为一个简单的逻辑核心。他们现在所做的就是为控制器对象设置依赖项，然后创建控制器对象。前控制器在这之前做所有事情，之后做所有事情。

事实上，甚至可以从页面脚本中提取此逻辑。称为依赖项注入容器的对象可以作为一系列闭包接收对象创建逻辑，每个页面脚本一个闭包。容器可以为我们处理对象创建，我们可以完全删除页面脚本。

因此，我们的最终重构将把所有对象创建逻辑提取到依赖项注入容器中。我们还将修改前端控制器以实例化控制器对象，而不需要页面脚本。这样做，我们将删除所有页面脚本，并且我们的应用程序将具有完全现代化的体系结构。