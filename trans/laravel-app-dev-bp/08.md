# 第八章。构建一个网络应用程序

在本章中，我们将创建一个问答网络应用程序。首先，我们将学习从 Laravel 中移除公共部分，以便能够使用一些共享托管解决方案。然后，我们将使用第三方扩展进行身份验证并处理访问权限。最后，我们将制作一个问题系统，允许评论和回答问题，一个标签系统，向上投票和向下投票，并选择最佳答案。我们将使用数据透视表来标记问题。我们还将受益于不同地方的 jQuery Ajax 请求。以下是本章将涉及的主题:

*   从 Laravel 4 中删除公共部分
*   安装 Sentry 2 和身份验证库，并设置访问权限
*   创建自定义过滤器
*   创建我们的注册和登录表单
*   创建我们的问题表和模型
*   用数据透视表创建我们的标记表
*   创建和处理我们的问题表单
*   创建我们的问题列表页面
*   创建我们的问题页面
*   创建我们的答案表和资源
*   按标签搜索问题

# 从 Laravel 4 中删除公共部分

在的一些真实案例中，你可能不得不坚持使用配置糟糕的共享网络托管解决方案，这些解决方案没有`www`、`public_html`或类似的文件夹。在这种情况下，您可能希望从您的 Laravel 4 安装中删除公共部分。要删除这个公共部分，有一些简单的步骤可以遵循:

1.  首先，确保您有一个正在运行的 Laravel 4 实例。
2.  然后，将`public`文件夹内的所有内容移动到父文件夹中(其中存在`app`、`bootstrap`、`vendor`等文件夹)，然后删除空白的公共文件夹。
3.  Next, open the `index.php` file (which we had just moved from the public folder), and find the following line:

    ```php
    require __DIR__.'/../bootstrap/autoload.php';
    ```

    将前一行替换为后一行:

    ```php
    require __DIR__.'/bootstrap/autoload.php';
    ```

4.  Now, find this line in the `index.php` file:

    ```php
    $app = require_once __DIR__.'/../bootstrap/start.php';
    ```

    将前一行替换为后一行:

    ```php
    $app = require_once __DIR__.'/bootstrap/start.php';
    ```

5.  Now, open the `paths.php` file under the `bootstrap` folder, and find this line:

    ```php
    'public' => __DIR__.'/../public',
    ```

    将前一行替换为后一行:

    ```php
    'public' => __DIR__.'/..',
    ```

6.  如果您使用的是虚拟主机，请不要忘记更改目录设置并重新启动 web 服务器。

在前面的步骤中，我们首先将所有内容从`public`文件夹移到`parent`文件夹，因为我们将不再使用`parent`片段。然后我们修改`index.php`文件来识别`autoload.php`和`start.php`的正确路径，这样框架就可以运行了。如果一切顺利，当你刷新页面时，你不会看到任何问题，这意味着你已经成功地从你的 Laravel 4 安装中删除了公共部分。

### 注

不要忘记，此方法将使您的所有代码在公共 web 根目录下可用，这可能会给您的项目带来安全问题。在这种情况下，你应该防止使用这种方法，或者你应该找到一个更好的网络托管解决方案。

# 安装哨兵 2 和认证库，设置访问权限

在本节中，我们将安装一个名为 Sentry 2 的用于用户身份验证和访问权限的第三方库，由**cartallyst**提供。Cartalyst 是一家以开发人员为中心的开源公司，非常注重文档、社区支持和框架。在本节中，我们将遵循 Sentry 官方的 Laravel 4 安装步骤，只需一个简单的额外步骤，该步骤目前可在[http://docs.cartalyst.com/sentry-2/installation/laravel-4](http://docs.cartalyst.com/sentry-2/installation/laravel-4)获得。

1.  首先，打开你的`composer.json`文件，在`require`属性中添加以下一行:

    ```php
    "cartalyst/sentry": "2.0.*"
    ```

2.  然后，运行 composer update 命令获取包:

    ```php
    php composer.phar update
    ```

3.  现在，在`app/config`下打开你的`app.php`文件，并在`providers`数组中添加以下一行:

    ```php
    'Cartalyst\Sentry\SentryServiceProvider',
    ```

4.  现在，在`app.php`中的`aliases`数组中添加以下行:

    ```php
    'Sentry' => 'Cartalyst\Sentry\Facades\Laravel\Sentry',
    ```

5.  现在，运行以下命令将所需的表(或用户)安装到数据库中:

    ```php
    php artisan migrate --package=cartalyst/sentry
    ```

6.  接下来，我们需要将 Sentry 2 的配置文件发布到我们的`app`文件夹中，这样我们就可以根据需要管理节流或其他设置。从您的终端运行以下命令:

    ```php
    php artisan config:publish cartalyst/sentry
    ```

7.  现在，我们应该改变默认的用户模型，以便能够与 Sentry 2 一起使用。在`app/models`下打开你的`User.php`文件，用以下代码替换它的所有内容:

    ```php
    <?php
    class User extends Cartalyst\Sentry\Users\Eloquent\User {
    }
    ```

8.  Lastly, we should create our admin user. Add the following code to your `routes.php` file under the `app` folder and run it once. Comment out or delete the code after that. We are practically assigning the admin ID=1 for our system, with an access right called `admin`.

    ```php
    /**
    * This method is to create an admin once.
    * Just run it once, and then remove or comment it out.
    **/
    Route::get('create_user',function(){

    $user = Sentry::getUserProvider()->create(array(
      'email' => 'admin@admin.com',
      //password will be hashed upon creation by Sentry 2
      'password' => 'password',
      'first_name' => 'John',
      'last_name' => 'Doe',
      'activated' => 1,
      'permissions' => array (
        'admin' => 1
      )
    ));
    return 'admin created with id of '.$user->id;
    });
    ```

    这样，您已经成功创建了一个以`admin@admin.com`作为电子邮件地址和`password`作为密码的用户。哨兵 2 创建时，密码将自动散列，因此我们不必在创建前对密码进行散列和加盐。我们已经将管理员的名字设置为`John`，将姓氏设置为`Doe`。此外，我们为刚刚生成的名为`admin`的用户设置了权限，以便在处理请求之前检查访问权限。

你现在都准备好了。如果一切顺利，并且您检查了数据库，您应该会看到由 Laravel 4 生成的迁移表(在 Laravel 3 的第一次迁移之前，您必须手动设置)和由 Sentry 2 生成的表。在`users`表中，您应该会看到由我们的闭包方法生成的用户条目。

现在我们的用户认证系统已经准备好了，我们需要生成我们的过滤器，然后创建注册和登录表单。

# 创建自定义过滤器

自定义过滤器将帮助我们过滤请求，将帮助我们预先进行一些预检查。得益于 Sentry 2 的内置方法，我们可以轻松定义自定义过滤器。但是首先我们需要定义一些路线，这些路线将在我们的项目中使用。

将以下代码添加到`app`文件夹下的`routes.php`文件中:

```php
//Auth Resource
Route::get('signup',array('as'=>'signup_form', 'before'=>
'is_guest', 'uses'=>'AuthController@getSignup'));
Route::post('signup',array('as'=>'signup_form_post', 'before' =>
'csrf|is_guest', 'uses' => 'AuthController@postSignup'));
Route::post('login',array('as'=>'login_post', 'before' =>
'csrf| is_guest', 'uses' => 'AuthController@postLogin'));
Route::get('logout',array('as'=>'logout', 'before'=>'
user', 'uses' => 'AuthController@getLogout'));
//---- Q & A Resources
Route::get('/',array('as'=>'index','uses'=>
'MainController@getIndex'));
```

在这些命名的资源中，名称用数组中的键`as`定义，过滤器用键`before`设置。可以看到，有一些`before`参数，比如`is_guest`和`user`。这些过滤器将在用户发出任何请求之前运行，甚至调用控制器。`uses`键设置调用资源时将要执行的控制器。稍后我们将为这些控制器编写代码。结果，例如，用户甚至不能尝试发布到登录表单。如果用户尝试这样做，我们的过滤器将在用户发出请求之前运行并进行过滤。

现在我们的路线已经准备好了，我们可以添加过滤器。要添加过滤器，请在`app`文件夹下打开您的`filters.php`文件，并添加以下代码:

```php
/*
 |----------------------------------------------------------- 
 | Q&A Custom Filters
 |-----------------------------------------------------------
*/

Route::filter('user',function($route,$request){
  if(Sentry::check()) {
    //is logged in
  } else {
    return Redirect::route('index')
      ->with('error','You need to log in first');
  }
});

Route::filter('is_guest',function($route,$request){
  if(!Sentry::check()) {
    //is a guest
  } else {
    return Redirect::route('index')
      ->with('error','You are already logged in');
  }
});

Route::filter('access_check',function($route,$request,$right){
  if(Sentry::check()) {
    if(Sentry::getUser()->hasAccess($right)) {
      //logged in and can access
    } else {
      return Redirect::route('index')
        ->with('error','You don\'t have enough priviliges to access that page');
    }
  } else {
    return Redirect::route('index')
      ->with('error','You need to log in first');
  }
});
```

方法`Route::filter()` 允许我们创建自己的过滤器。第一个参数是过滤器的名称，第二个参数是闭包函数，它本身至少有两个参数。如果需要给过滤器提供一个参数，可以将其作为第三个参数添加。

无论用户是否登录，哨兵 2 的`check()`助手函数都会返回一个布尔值。如果返回 true，则表示用户已登录，否则浏览网页的用户当前未登录。在我们的定制过滤器`user`和`is_guest`中，我们准确地检查了这一点。过滤器的 passing 子句可以留空。但是如果用户不能满足过滤器的条件，可以采取适当的措施。在我们的示例中，我们将用户重定向到我们的`index`路线。

然而，我们的第三个过滤器`access_check`稍微复杂一点。如您所见，我们添加了第三个参数`$right`，我们将通过调用过滤器。该过滤器检查两个条件。首先，检查用户是否使用`Sentry::check()`方法登录。然后，它使用`hasAccess()`方法检查用户是否可以访问`$right`部分(我们将在定义过滤器时看到)。但是这个方法需要一个当前登录的用户。为此，我们将使用哨兵 2 的`getUser()`方法验证当前用户的信息。

要在调用过滤器时传递参数，可以使用`filter_name:parameter1, parameter2`。在我们的例子中，我们将使用过滤器`access_check:admin`检查用户是否是管理员。

要在`before`参数中使用多个过滤器，请在参数之间添加一个`|`字符。在我们的例子中，我们的登录帖子和注册资源过滤器被定义为`csrf|guest` (csrf 是由 Laravel 自己在我们的`filters.php`文件中预定义的)。

# 创建我们的注册和登录表单

在创建我们的注册和登录表单之前，我们需要一个模板来设置部分。我将使用为本章生成的自定义 HTML/CSS 模板，其灵感来自开源 Q & A 脚本的**雪**主题，T5】问题 2 答案。

我们执行以下步骤来创建注册和登录表单:

1.  首先，将所提供示例代码的`assets`文件夹中的所有内容复制到您的项目文件夹的根目录下(这里是`app`、`bootstrap`和其他文件夹的位置)，因为我们已经删除了本章第一节中的公共文件夹部分。
2.  Next, add the following code to your `template_masterpage.blade.php` file under `app/views`:

    ```php
    <!DOCTYPE html>
    <!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7">
    <![endif]-->
    <!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8">
    <![endif]-->
    <!--[if IE 8]> <html class="no-js lt-ie9">
    <![endif]-->
    <!--[if gt IE 8]><!--> <html class="no-js">
    <!--<![endif]-->

    <head>
      <meta charset="utf-8" />
      <title>{{isset($title)?$title.' | ':''}} LARAVEL Q & A
      </title>
      {{ HTML::style('assets/css/style.css') }}
    </head>
    <body>

      {{-- We include the top menu view here --}}
      @include('template.topmenu')

      <div class="centerfix" id="header">
      <div class="centercontent">
        <a href="{{URL::route('index')}}">
          {{HTML::image('assets/img/header/logo.png')}}
        </a>
      </div>
      </div>
      <div class="centerfix" id="main" role="main">
      <div class="centercontent clearfix">
        <div id="contentblock">

        {{-- Showing the Error and Success Messages--}}
        @if(Session::has('error'))
        <div class="warningx wredy">
          {{Session::get('error')}}
        </div>
        @endif

        @if(Session::has('success'))
        <div class="warningx wgreeny">
          {{Session::get('success')}}
        </div>
        @endif

        {{-- Content section of the template --}}
        @yield('content')
        </div>
      </div>
      </div>
      {{-- JavaScript Files --}}
      {{ HTML::script('assets/js/libs.js') }}
      {{ HTML::script('assets/js/plugins.js') }}
      {{ HTML::script('assets/js/script.js') }}

      {{-- Each page's custom assets (if available) will be yielded here --}}
      @yield('footer_assets')

    </body>
    </html>
    ```

    现在，让我们挖掘代码:

    *   如果我们加载一个带有`title`属性的视图，`<title>`标签将包含标题；否则它只会显示我们网站的名称。
    *   `HTML`类的`style()`方法将帮助我们轻松地将 CSS 文件添加到模板中。此外，`HTML`类的`script()`方法允许我们向输出的 HTML 文件中添加 JavaScript。
    *   我们使用刀片模板引擎的`@include()`方法将另一个文件包含到我们的`template_masterpage.blade.php`文件中。我们将在下一步中描述它的各个部分。
    *   `URL`类的`route()`方法将返回一个到指定路线的链接。这实际上非常方便，因为如果我们改变网址结构，我们就不需要深入所有模板文件并编辑所有链接。
    *   `HTML`类的`image()`方法允许我们将`<img>`标签添加到模板中。
    *   在过滤器中，我们使用参数为`error`的`with()`方法重定向到路线页面。如果我们使用`with()`加载页面(`View::make()`，参数将是变量。但是因为我们已经将用户重定向到一个页面，这些通过`with()`传递的参数将是一个会话 flashdata，它将只可用一次。为了检查是否设置了这些会话，我们使用了`Session`类的`has()`方法。`Session::has('sessionName')`将返回一个布尔值来标识是否设置了会话。如果设置好了，我们可以使用`Session`类的`get()`方法在视图、控制器和其他地方使用它。
    *   Blade 模板引擎的`@yield()`方法获取`@section()`中存在的数据，并将其解析到主模板页面。
3.  In the previous section, we included another view by calling the `@include()` method as `@include('template.topmenu')`. Now save the following code as `topmenu.blade.php` under `app/views/template`:

    ```php
    {{-- Top error (about login etc.) --}}
    @if(Session::has('topError'))
      <div class="centerfix" id="infobar">
        <div class="centercontent">{{ Session::get('topError') }}
        </div>
      </div>
    @endif

    {{-- Check if a user is logged in, login and logout has different templates --}}
    @if(!Sentry::check())
    <div class="centerfix" id="login">
      <div class="centercontent">
        {{Form::open(array('route'=>'login_post'))}}
        {{Form::email('email', Input::old('email'), array('placeholder'=>'E-mail Address'))}}
        {{Form::password('password', array('placeholder' => 'Password'))}}
        {{Form::submit('Log in!')}}
        {{Form::close()}}

        {{HTML::link('signup_form','Register',array(),array('class'=>'wybutton'))}}
      </div>
    </div>
    @else
      <div class="centerfix" id="login">
        <div class="centercontent">
          <div id="userblock">Hello again, {{HTML::link('#',Sentry::getUser()->first_name.' '.Sentry::getUser()->last_name)}}</div>
          {{HTML::linkRoute('logout','Logout',array(),array('class'=>'wybutton'))}}
        </div>
      </div>
    @endif
    ```

    现在，让我们挖掘代码:

    *   在我们的模板中，我们有两条错误消息，其中第一条完全保留在登录区域，将显示在顶部。我把它命名为`error_top`。使用我们刚刚学习的方法`has()`和`get()`，我们检查是否存在错误，并显示它。
    *   顶部菜单将取决于用户是否登录。因此，我们使用哨兵 2 的用户检查方法`check()`创建一个`if`子句，并检查用户是否登录。如果用户没有登录(访客)，我们会显示我们使用`Form`类制作的登录表单，否则我们会向用户显示带有个人资料的`infobar`和**注销**按钮。
4.  现在，我们需要一个登记表页面。我们已经在`app`文件夹下的`routes.php`文件中定义了它的方法:

    ```php
    //Auth Resource
    Route::get('signup',array('as'=>'signup_form', 'before' => 'is_guest', 'uses' => 'AuthController@getSignup'));
    Route::post('signup',array('as' => 'signup_form_post', 'before' => 'csrf|is_guest', 'uses' => 'AuthController@postSignup'));
    ```

5.  根据我们创建的路线资源，我们需要一个名为`AuthController`的控制器，它有两个方法，分别叫做`getSignup()`和`postSignup()`。现在让我们首先创建控制器。打开终端，输入以下命令:

    ```php
    php artisan controller:make AuthController

    ```

6.  前一个命令会用一些默认方法在`app/controllers`下创建一个新文件`AuthController.php`。删除`AuthController`类中的代码，并在该类中添加以下代码，以制作注册表单:

    ```php
    /**
      * Signup GET method
    **/
    public function getSignup() {
      return View::make('qa.signup')
        ->with('title','Sign Up!');
    }
    ```

7.  我们现在需要一个视图文件来制作表单。将以下代码保存为`app/views/qa`下的`signup.blade.php`:

    ```php
    @extends('template_masterpage')

    @section('content')
      <h1 id="replyh">Sign Up</h1>
      <p class="bluey">Please fill all the credentials correctly to register to our site</p>
      {{Form::open(array('route'=>'signup_form_post'))}}
        <p class="minihead">First Name:</p>
        {{Form::text('first_name',Input::get('first_name'),array('class'=>'fullinput'))}}
        <p class="minihead">Last Name:</p>
        {{Form::text('last_name',Input::get('last_name'),array('class'=>'fullinput'))}}<p class="minihead">E-mail address:</p>
        {{Form::email('email',Input::get('email'),array('class'=>'fullinput'))}}
        <p class="minihead">Password:</p>
        {{Form::password('password','',array('class'=>'fullinput'))}}
        <p class="minihead">Re-password:</p>
        {{Form::password('re_password','',array('class'=>'fullinput'))}}
        <p class="minihead">Your personal info will not be shared with any 3rd party companies.</p>
        {{Form::submit('Register now!')}}
      {{Form::close()}}
    @stop
    ```

如果您已经将的所有内容都做对了，当您导航到`chapter8.dev/signup`时，您应该会看到以下表格:

![Creating our registration and login forms](graphics/2111OS_08_01.jpg)

## 验证和处理表单

现在，我们需要验证和处理表单。我们首先需要定义我们的验证规则。在`app/models`下的`user.php`文件中的`User`类中添加以下代码:

```php
public static $signup_rules = array(
  'first_name' => 'required|min:2',
  'last_name' => 'required|min:2',
  'email' => 'required|email|unique:users,email',
  'password' => 'required|min:6',
  're_password' => 'required|same:password'
);
```

前面代码中提到的规则会使所有字段`required`。我们将`first_name`和`last_name`列设置为`required`，并且我们设置了两个字符的最小长度。我们将`email`字段设置为有效的电子邮件格式，代码将检查`users`表(在安装 Sentry 2 时创建)中唯一的电子邮件地址。我们将`password`字段设置为`required`，长度至少为六个字符。我们还设置了`re_password`字段来匹配`password`字段，这样我们就可以确保密码输入正确。

### 注

Sentry 2 还可以在用户尝试登录时抛出一个唯一的电子邮件检查异常。

在处理表单之前，我们需要一个伪索引页面，在注册成功后返回用户。我们将通过执行以下步骤来创建临时索引页:

1.  首先，运行以下命令创建一个新的控制器:

    ```php
    php artisan controller:make MainController

    ```

2.  然后，移除所有自动插入的方法，并在类内添加以下方法:

    ```php
    public function getIndex() {
      return View::make('qa.index');
    }
    ```

3.  现在，将此视图文件保存为`app/views/qa`下的`index.blade.php`:

    ```php
    @extends('template_masterpage')

    @section('content')
    Heya!
    @stop
    ```

4.  Now, we need a controller method (which we defined in `routes.php`) to process the `signup` form's `post` request. To do this, add the following code to your `AuthController.php` file under `app/controllers`:

    ```php
    /**
      * Signup Post Method
    **/
    public function postSignup() {

      //Let's validate the form first
      $validation = Validator::make(Input::all(),User::$signup_rules);

      //let's check if the validation passed
      if($validation->passes()) {

        //Now let's create the user with Sentry 2's create method
        $user = Sentry::getUserProvider()->create(array(
          'email' => Input::get('email'),
          'password' => Input::get('password'),
          'first_name' => Input::get('first_name'),
          'last_name' => Input::get('last_name'),
          'activated' => 1
        ));

        //Since we don't use an email validation in this example, let's log the user in directly
        $login = Sentry::authenticate(array('email'=>Input::get('email'),'password'=>Input::get('password')));

        return Redirect::route('index')
          ->with('success','You\'ve signed up and logged in successfully!');
        //if the validation failed, let's return the user 
        //to the signup form with the first error message
      } else {
        return Redirect::route('signup_form')
        ->withInput(Input::except('password','re_password'))
          ->with('error',$validation->errors()->first());
      }
    }
    ```

    现在，让我们挖掘代码:

    1.  首先，我们使用 Laravel 的内置表单验证类，使用我们在模型中定义的规则来检查表单项。
    2.  我们使用`passes()`方法检查表单验证是否通过。我们也可以使用`fails()`方法检查完全相反的情况。

    如果验证失败，我们使用`withInput()` 返回给定凭证的**注册**表单。但是通过使用`Input::except()`，我们过滤了一些列，如`password`和`re_password`，因此这些字段中的值不会被返回。此外，通过使用`with`传递参数，表单验证的错误消息被返回。`$validation->errors()->first()`返回表单验证步骤后的第一个错误消息字符串。

    ![Validating and processing the form](graphics/2111OS_08_02.jpg)

    如果验证通过，我们将使用提供的凭据创建一个新用户。我们已经将列`activated`设置为`1`，因此在我们的示例中，注册过程不需要电子邮件验证。

    ### 注

    哨兵 2 还使用 try/catch 子句来捕获错误。不要忘记检查哨兵 2 的文档，学习如何捕捉异常错误。

5.  由于我们没有使用电子邮件验证系统，我们可以在注册后使用哨兵 2 的`authenticate()`方法简单地验证并登录用户。第一个参数取`email`和`password`的数组(与`key => value`匹配)，可选的第二个参数取一个布尔值作为输入，检查用户是否被记住(点击`remember me`按钮)。
6.  After the authentication, we simply redirect the user to our `index` route with a success message, as shown in the following screenshot:

    ![Validating and processing the form](graphics/2111OS_08_03.jpg)

## 处理登录和注销请求

现在我们的注册系统已经准备好了，我们需要处理登录和注销请求。由于我们的登录表单已经准备好了，我们可以直接进行处理。为了处理登录和注销请求，我们执行以下步骤:

1.  首先，我们需要登录表单验证规则。将以下代码添加到`app/models`下的`User.php`文件中:

    ```php
    public static $login_rules = array(
    	'email'		=> 'required|email|exists:users,email',
    	'password'	=> 'required|min:6'
    );
    ```

2.  Now, we need a controller method to process the login request. Add the following code to your `AuthController.php` file under `app/controllers`:

    ```php
    /**
     * Login Post Method Resource
    **/
    public function postLogin() {
      //let's first validate the form:
      $validation = Validator::make(Input::all(),User::$login_rules);

      //if the validation fails, return to the index page with first error message
      if($validation->fails()) {
        return Redirect::route('index')
          ->withInput(Input::except('password'))
          ->with('topError',$validation->errors()->first());
      } else {

        //if everything looks okay, we try to authenticate the user
        try {

          // Set login credentials
          $credentials = array('email' => Input::get('email'),'password' => Input::get('password'),);

          // Try to authenticate the user, remember me is set to false
          $user = Sentry::authenticate($credentials, false);
          //if everything went okay, we redirect to index route with success message
          return Redirect::route('index')
            ->with('success','You\'ve successfully logged in!');
        } catch (Cartalyst\Sentry\Users\LoginRequiredException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','Login field is required.');
        } catch (Cartalyst\Sentry\Users\PasswordRequiredException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','Password field is required.');
        } catch (Cartalyst\Sentry\Users\WrongPasswordException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','Wrong password, try again.');
        } catch (Cartalyst\Sentry\Users\UserNotFoundException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','User was not found.');
        } catch (Cartalyst\Sentry\Users\UserNotActivatedException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','User is not activated.');
        }

        // The following is only required if throttle is enabled
        catch (Cartalyst\Sentry\Throttling\UserSuspendedException $e) {
        return Redirect::route('index')
          -> withInput(Input::except('password'))
          ->with('topError','User is suspended.');
        } catch (Cartalyst\Sentry\Throttling\UserBannedException $e) {
          return Redirect::route('index')
            -> withInput(Input::except('password'))
            ->with('topError','User is banned.');
        }
      }
    }
    ```

    现在，让我们挖掘代码:

    1.  首先，我们使用我们在模型中定义的规则，通过 Laravel 的内置表单验证类来检查表单项。
    2.  Then we check whether the form validation has failed using the `fails()` method of the form validation class. If the form validation fails, we return the user to the `index` route with the first form validation error.

        ![Processing the login and logout requests](graphics/2111OS_08_04.jpg)

    3.  The `else` clause in the previous code holds the events that will be done if the form validation passes. In this, we authenticate a user using the try/catch clauses of Sentry 2, catch all the exceptions, and return an error message according to the type of exception.

        在我们的示例应用程序中，我们不需要所有的异常，但是作为一个示例，我们尝试显示所有的异常，以防您在跟进时需要做一些不同的事情。

        ### 注

        所有这些尝试/捕获异常都记录在哨兵 2 的网站上。

    4.  如果 Sentry 2 没有抛出异常，我们将返回带有成功消息的索引页面。
3.  Now, the only thing remaining regarding authentication is the logout button. To create one, add the following code to the `AuthController.php` file under `app/controllers`:

    ```php
    /**
      * Logout method 
    **/
    public function getLogout() {
      //we simply log out the user
      Sentry::logout();

      //then, we return to the index route with a success message
      return Redirect::route('index')
        ->with('success','You\'ve successfully signed out');
    }
    ```

    现在让我们挖掘代码:

    1.  首先我们调用 Sentry 2 的`logout()`方法，将用户注销。
    2.  然后，我们简单地将用户(目前是客人)返回到`index`路线，并显示一条成功消息，告知他们已经成功注销。

既然我们的身份验证系统已经准备好了，我们就可以创建问题表了。

# 创建我们的问题表和模型

现在我们已经有了一个全面运行的认证系统，我们准备创建我们的`questions`表。为了创建我们的`questions`表，我们将使用数据库迁移。

要创建迁移，请在终端中运行以下命令:

```php
php artisan migrate:make create_questions_table --table= questions --create

```

上一个命令将在`app/database/migrations`下创建一个新的迁移。

对于问题，我们需要问题标题、问题详细信息、问题标题、问题日期、问题被查看的次数、投票总数和问题标签。

现在，打开您刚刚创建的迁移，并用以下代码替换其内容:

```php
Schema::create('questions', function(Blueprint $table)
{
  //Question's ID
  $table->increments('id');
  //title of the question
  $table->string('title',400)->default('');
  //asker's id
  $table->integer('userID')->unsigned()->default(0);
  //question's details
  $table->text('question')->default('');
  //how many times it's been viewed:
  $table->integer('viewed')->unsigned()->default(0);
  //total number of votes:
  $table->integer('votes')->default(0);
  //Foreign key to match userID (asker's id) to users
  $table->foreign('userID')->references('id')->on('users')->onDelete('cascade');
  //we will get asking time from the created_at column
  $table->timestamps();
});
```

对于标签，我们将使用一个透视表，这就是为什么它们没有出现在我们当前的模式中。对于投票，在这个例子中，我们只是拿着一个整数(可以是正的也可以是负的)。在现实应用程序中，您可能希望使用第二个透视表来保存用户的投票，防止双重投票，并获得更准确的结果。

1.  现在您的模式已经准备好了，使用以下命令运行迁移:

    ```php
    php artisan migrate

    ```

2.  成功迁移模式后，我们现在需要一个模型来受益于雄辩。将以下代码保存为`app/models`下的`Question.php`:

    ```php
    <?php

    class Question extends Eloquent {

      protected $fillable = array('title', 'userID', 'question', 'viewed', 'answered', 'votes');

    }
    ```

3.  现在，我们需要数据库关系来匹配表。首先，在`app/models`下的`User.php`文件中添加以下代码:

    ```php
    public function questions() {
      return $this->hasMany('Question','userID');
    }
    ```

4.  接下来，在`app/models`下的`Question.php`文件中添加以下代码:

    ```php
    public function users() {
      return $this->belongsTo('User','userID');
    }
    ```

由于用户可能有多个问题，我们在`User`模型中使用了`hasMany()`方法来处理关系。此外，由于所有问题都属于用户，我们使用了`belongsTo()`方法来匹配用户的问题。在这些方法中，第一个参数是模型名称，在我们的例子中是`Question`和`User`。第二个参数是该模型中匹配表的列名，在我们的例子中是`userID`。

# 用数据透视表创建标签表

首先，我们应该理解为什么我们需要标签的透视表。在现实世界中，一个问题可能有多个标签；此外，一个标签可能有多个问题。在这种情况下(多对多关系)，两个表可能有多个表来正确匹配它们，我们应该创建并使用第三个数据透视表。

1.  首先，我们应该使用模式创建一个新的标签表。打开您的终端并运行以下命令来创建我们的数据透视表模式:

    ```php
    php artisan migrate:make create_tags_table --table= tags --create

    ```

2.  Now we need to fill the table's contents. In our example, we just need the tag name and tag's friendly URL name. Replace the schema's `up` function contents with the following code:

    ```php
    Schema::create('tags', function(Blueprint $table)
    {
      //id is needed to match pivot
      $table->increments('id');

      //Tag's name
      $table->string('tag')->default('');
      //Tag's URL-friendly name
      $table->string('tagFriendly')->unique();

      //I like to keep timestamps
      $table->timestamps();
    });
    ```

    我们有`id`列来将问题与数据透视表中的标签进行匹配。我们有一个字符串字段`tag`，这将是标签的标题，而列`tagFriendly`将显示为一个网址。我还保留了时间戳，这样，在将来，它可以给我们关于标签创建时间的信息。

3.  最后，在您的终端中运行以下命令来运行迁移并安装表:

    ```php
    php artisan migrate

    ```

4.  现在，我们需要一个`tags`表的模型。将以下文件保存为`app/models`下的`Tag.php`:

    ```php
    <?php

    class Tag extends Eloquent {

      protected $fillable = array('tag', 'tagFriendly');

    }
    ```

5.  Now, we need to create our pivot table. As a good practice, its name should be `modelname1_modelname2`, and its content sorted alphabetically. In our example, we have the `questions` and `tags` table, so we will set the pivot table's name as `question_tags` (this is not forced, you can give any name to your pivot table). As you may guess, its schema will have two columns to match the two tables and two foreign keys for these columns. You can even add additional columns to the pivot table.

    要创建迁移文件，请在终端中运行以下命令:

    ```php
    php artisan migrate:make create_question_tags_table --table=question_tags --create

    ```

6.  Now, open the schema that we've generated in the `migrations` folder under `app/database` and alter its `up()` method contents with the following code:

    ```php
    Schema::create('question_tags', function(Blueprint $table)
    {
      $table->increments('id');

      $table->integer('question_id')->unsigned()->default(0);
      $table->integer('tag_id')->unsigned()->default(0);

      $table->foreign('question_id')->references('id')->on('questions')->onDelete('cascade');
      $table->foreign('tag_id')->references('id')->on('tags')->onDelete('cascade');

      $table->timestamps();
    });
    ```

    我们需要两列，它的名字结构应该是`modelname_id`。在我们的移民中，他们是`question_id`和`tag_id`。此外，我们已经设置了外键来匹配数据库中的外键。

7.  现在，运行迁移并安装表:

    ```php
    php artisan migrate

    ```

8.  Now, we need to add methods to describe to Eloquent that we are using a pivot table. To teach the pivot information to the question model, add the following code to the `Question.php` file under `app/models`:

    ```php
    public function tags() {
      return $this->belongsToMany('Tag','question_tags')->withTimestamps();
    }
    ```

    要描述标签模型的透视信息，请在`app/models`下的`Tag.php`文件中添加以下代码:

    ```php
    public function questions() {
      return $this->belongsToMany('Question','question_tags')->withTimestamps();
    }
    ```

    `belongsToMany()`方法中的第一个参数是模型名称，第二个参数是透视表的名称。使用`withTimestamps()`(这将为我们带来数据透视表的创建和更新日期)是可选的。此外，如果我们有一些额外的数据要添加到数据透视表中，我们可以使用方法`withPivot()`来调用它。考虑以下示例代码:

    ```php
    $this->belongsToMany('Question ', 'question_tags')->withPivot('column1', 'column2')->withTimestamps();
    ```

现在我们的透视表结构已经准备好了，在后面的章节中，我们可以很容易地获取问题的标签和所有用$ `tagname`标记的问题。

# 创建和处理我们的问题表单

现在我们的结构已经准备好了，我们可以开始创建和处理我们的问题表单了。

## 创建我们的问题表单

我们执行以下步骤来创建我们的问题表单:

1.  首先，我们需要一个新的问题表单路由资源。在`app`文件夹中打开您的`routes.php`文件，并添加以下代码:

    ```php
    Route::get('ask',array('as'=>'ask', 'before'=>'user', 
       'uses' => 'QuestionsController@getNew'));

    Route::post('ask',array('as'=>'ask_post', 
      'before'=>'user|csrf', 'uses' => 
      'QuestionsController@postNew'));
    ```

2.  Now that our resource is defined, we need to add the resource to our top menu for navigation. Open your `topmenu.blade.php` file under `app/views/template`, and find the following line:

    ```php
    {{HTML::linkRoute('logout','Logout',array(), array('class'=>'wybutton'))}}
    ```

    在下一行上方添加上一行:

    ```php
    {{HTML::linkRoute('ask','Ask a Question!', array(), array('class'=>'wybutton'))}}
    ```

3.  现在，我们需要控制器文件来处理资源。在您的终端中运行以下命令:

    ```php
    php artisan controller:make QuestionsController

    ```

4.  接下来，在`app/controllers`下打开新创建的`QuestionsController.php`文件，删除类内的所有方法。然后添加以下代码:

    ```php
    /**
      * A new question asking form
    **/
    public function getNew() {
      return View::make('qa.ask')
        ->with('title','New Question');
    }
    ```

5.  Now, we need to create the view we've just assigned. Save the following code as `ask.blade.php` under `app/views/qa`:

    ```php
    @extends('template_masterpage')

    @section('content')

      <h1 id="replyh">Ask A Question</h1>
      <p class="bluey">Note: If you think your question's been answered correctly, please don't forget to click "✓" icon to mark the answer as "correct".</p>
      {{Form::open(array('route'=>'ask_post'))}}

      <p class="minihead">Question's title:</p>
      {{Form::text('title',Input::old('title'),array('class'=>'fullinput'))}}

      <p class="minihead">Explain your question:</p>
      {{Form::textarea('question',Input::old('question'),array('class'=>'fullinput'))}}

      <p class="minihead">Tags: Use commas to split tags (tag1, tag2 etc.). To join multiple words in a tag, use - between the words (tag-name, tag-name-2):</p>
      {{Form::text('tags',Input::old('tags'),array('class'=>'fullinput'))}}
      {{Form::submit('Ask this Question')}}
      {{Form::close()}}

    @stop
    @section('footer_assets')

      {{-- A simple jQuery code to lowercase all tags before submission --}}
      <script type="text/javascript">
        $('input[name="tags"]').keyup(function(){
          $(this).val($(this).val().toLowerCase());
        });
      </script>

    @stop
    ```

    除了我们之前创建的视图之外，在这个视图中，我们通过填充`footer_assets`部分向页脚添加了一个 JavaScript 代码，这是我们之前在母版页中定义的。

6.  If you have done everything correctly, when you navigate to `site.com/ask`, you will see a form styled like the following screenshot:

    ![Creating our questions form](graphics/2111OS_08_05.jpg)

既然我们的问题表单已经准备好了，我们就准备处理表单。

## 处理我们的问题表单

为了处理表单，我们需要一些验证规则和控制器方法。

1.  首先，将以下表单验证规则添加到您的`app/models`下的`Question.php`文件中:

    ```php
    public static $add_rules = array('title' => 'required|min:2','question' => 'required|min:10');
    ```

2.  After saving the question successfully, we would like to provide the question's permalink to the user, so the user can access the question easily. But to do this, we first need to define a route to create this link. Add the following line into your `routes.php` file in the `app` folder:

    ```php
    Route::get('question/{id}/{title}',array('as'=> 'question_details', 'uses' => 'QuestionsController@getDetails' ))-> where(array('id'=>'[0-9]+' , 'title' => '[0-9a-zA-Z\-\_]+'));
    ```

    我们在这条路线中设置了两个参数，`id`和`title`。`id`参数必须是正整数，而`title`应该只包含字母数字字符、分数和下划线。

3.  Now, we are ready to process the question form. Add the following code to your `QuestionsController.php` file under `app/controllers`:

    ```php
    /**
     * Post method to process the form
    **/
    public function postNew() {

      //first, let's validate the form
      $validation = Validator::make(Input::all(), Question::$add_rules);

      if($validation->passes()) {
        //First, let's create the question
        $create = Question::create(array('userID' => Sentry::getUser()->id,'title' => Input::get('title'),'question' => Input::get('question')
        ));

        //We get the insert id of the question
        $insert_id = $create->id;

        //Now, we need to re-find the question to "attach" the tag to the question
        $question = Question::find($insert_id);

        //Now, we should check if tags column is filled, and split the string and add a new tag and a relation
        if(Str::length(Input::get('tags'))) {
          //let's explode all tags from the comma
          $tags_array = explode(',', Input::get('tags'));
          //if there are any tags, we will check if they are new, if so, we will add them to database
          //After checking the tags, we will have to "attach" tag(s) to the new question 
          if(count($tags_array)) {
            foreach ($tags_array as $tag) {
              //first, let's trim and get rid of the extra space bars between commas 
              //(tag1, tag2, vs tag1,tag2) 
              $tag = trim($tag);

              //We should double check its length, because the user may have just typed "tag1,,tag2" (two or more commas) accidentally
              //We check the slugged version of the tag, because tag string may only be meaningless character(s), like "tag1,+++//,tag2"
              if(Str::length(Str::slug($tag))) {
                //the URL-Friendly version of the tag
                $tag_friendly = Str::slug($tag);

                //Now let's check if there is a tag with the url friendly version of the provided tag already in our database:
                $tag_check = Tag::where('tagFriendly',$tag_friendly);

                //if the tag is a new tag, then we will create a new one
                if($tag_check->count() == 0) {
                  $tag_info = Tag::create(array('tag' => $tag,'tagFriendly' => $tag_friendly));

                  //If the tag is not new, this means There was a tag previously added on the same name to another question previously
                  //We still need to get that tag's info from our database 
                } else {
                  $tag_info = $tag_check->first();
                }
              }

              //Now the attaching the current tag to the question
              $question->tags()->attach($tag_info->id);
            }
          }
        }

        //lastly, we should return the user to the asking page with a permalink of the question
        return Redirect::route('ask')
          ->with('success','Your question has been created successfully! '.HTML::linkRoute('question_details','Click here to see your question',array('id'=>$insert_id,'title'=>Str::slug($question->title))));

      } else {
        return Redirect::route('ask')
          ->withInput()
          ->with('error',$validation->errors()->first());
      }
    }
    ```

    现在，让我们挖掘代码:

    1.  首先，我们运行表单验证类来检查这些值是否有效。如果验证失败，我们将用户返回到问题页面，显示他提供的旧输入和第一条验证错误消息。
    2.  如果验证通过，我们继续处理表单。我们首先创建并添加问题，向数据库添加一个新行，然后获取刚刚创建的行。为了获取当前用户的 ID，我们使用哨兵 2 的`getUser()`方法的`id`对象，它返回当前登录用户的信息。
    3.  创建问题后，我们检查`tags`字段的长度。如果字段不是空的，我们在逗号处分割字符串，并制作一个原始的`tags`数组。
    4.  之后，我们循环遍历我们拆分的每个标签，并使用`String`类的 Laravel 4 的`slug()`方法制作它们的友好 URL 版本。如果重击版本有一个长度，它是一个有效的标签。
    5.  找到所有有效的标签后，我们检查数据库，看是否有已经创建的标签。如果是这样，我们就得到它的 ID。如果标签对于系统是新的，那么我们创建一个新的标签。所以，通过这种方式，我们避免了系统中不必要的多个标签。
    6.  在之后，我们使用方法`attach()`在透视表中创建新的标签。要附加一个新的关系，首先需要找到我们要附加的 ID，然后转到附件的模型，使用`attach()`方法。
    7.  在我们的示例中，我们需要将问题附加到标签上。所以我们找到需要附加的问题，用多对多的关系来表示标签会被附加到问题上，并将标签的`id`附加到问题上。
    8.  如果一切顺利，您应该会被重定向回问题页面，并显示成功消息和您的问题的永久链接。
    9.  Also, if you check your `question_tags` table, you will see the relation data filled.

        ### 注

        始终验证和过滤来自表单的内容，并确保您不接受任何不需要的内容。

    成功添加问题后，您应该会看到如下截图所示的页面:

    ![Processing our questions form](graphics/2111OS_08_06.jpg)

# 创建我们的问题列表页面

现在我们可以创建问题了，是时候用实际的问题数据填充我们的虚拟索引页面了。为此，请在`app/controllers`下打开您的`MainController.php`文件，并用以下代码更改功能`getIndex()`:

```php
public function getIndex() {
  return View::make('qa.index')
    ->with('title','Hot Questions!')
    ->with('questions',Question::with('users','tags')->orderBy('id','desc')->paginate(2));
}
```

在这个方法中，我们加载了同一个页面，但是我们添加了两个名为`title`和`questions`的变量。`title`变量是我们应用程序的动态标题，`questions`变量保存最后两个问题，带有分页。代替`get()`，如果你使用`paginate($number)`，你可以得到一个现成的分页系统。另外，使用`with()`方法，我们急切地将`users`和`tags`关系直接加载到问题集合中，以获得更好的性能。

在视图中，我们将为问题提供一个粗略的向上/向下投票选项，并为标有`$tag`的问题提供一个路线链接。为此，我们需要一些新的路线。将以下代码添加到`app`文件夹下的`routes.php`文件中:

```php
//Upvoting and Downvoting
Route::get('question/vote/{direction}/{id}',array('as'=> 'vote', 'before'=>'user', 'uses'=> 'QuestionsController@getvote'))->where (array('direction'=>'(up|down)', 'id'=>'[0-9]+'));

//Question tags page
Route::get('question/tagged/{tag}',array('as'=>'tagged','uses'=>'QuestionsController@getTaggedWith'))->where('tag','[0-9a-zA-Z\-\_]+');
```

现在在`app/views/qa`下打开你的`index.blade.php`文件，用下面的代码修改整个文件:

```php
@extends('template_masterpage')

@section('content')
  <h1>{{$title}}</h1>

  @if(count($questions))

    @foreach($questions as $question)

      <?php
        //Question's asker and tags info
        $asker = $question->users;
        $tags = $question->tags;	 
      ?>

      <div class="qwrap questions">
        {{-- Guests cannot see the vote arrows --}}
        @if(Sentry::check())
          <div class="arrowbox">
            {{HTML::linkRoute('vote','',array('up', $question->id),array('class'=>'like', 'title'=>'Upvote'))}}
            {{HTML::linkRoute('vote','',array('down',$question->id),array('class'=>'dislike','title'=>'Downvote'))}}
          </div>
        @endif

        {{-- class will differ on the situation --}}
        @if($question->votes > 0)
          <div class="cntbox cntgreen">
        @elseif($question->votes == 0)
          <div class="cntbox">
        @else
          <div class="cntbox cntred">
        @endif
        <div class="cntcount">{{$question->votes}}</div>
        <div class="cnttext">vote</div>
        </div>

        {{--Answer section will be filled later in this chapter--}}
        <div class="cntbox">
          <div class="cntcount">0</div>
          <div class="cnttext">answer</div>
        </div>

        <div class="qtext">
          <div class="qhead">
            {{HTML::linkRoute('question_details',$question->title,array($question->id,Str::slug($question->title)))}}
          </div>
          <div class="qinfo"">Asked by <a href="#">{{$asker->first_name.' '.$asker->last_name}}</a> around {{date('m/d/Y H:i:s',strtotime($question->created_at))}}</div>
          @if($tags!=null)
            <ul class="qtagul">
              @foreach($tags as $tag)
                <li>{{HTML::linkRoute('tagged',$tag->tag,$tag->tagFriendly)}}</li>
              @endforeach
            </ul>
          @endif
        </div>
      </div>
    @endforeach

    {{-- and lastly, the pagination --}}
    {{$questions->links()}}

  @else
    No questions found. {{HTML::linkRoute('ask','Ask a question?')}}
  @endif

@stop
```

既然我们已经设置了关系，我们就可以直接使用`$question->users`访问问题，或者`$question->tags`直接访问问题的标签。

方法`links()`带来了 Laravel 内置的分页系统。系统已准备好与引导程序一起使用。我们也可以从`app/config`下的`view.php`文件中更改它的外观。

如果您一直跟进到这里，当您导航到您的索引页面时，在插入一些新问题后，您将看到如下截图所示的视图:

![Creating our questions list page](graphics/2111OS_08_07.jpg)

现在，我们需要为向上投票和向下投票按钮添加功能。

## 增加上投票和下投票功能

向上投票和向下投票按钮几乎会出现在项目的每一页上，所以将它们添加到母版页是一个更好的实践，而不是将它们多次添加和克隆到每个模板中。

为此，请在`app/views`下打开您的`template_masterpage.php`文件，并找到以下行:

```php
@yield('footer_assets')
```

在前一个代码下面添加以下代码:

```php
{{-- if the user is logged in and on index or question details page--}}
@if(Sentry::check() && (Route::currentRouteName() == 'index' || Route::currentRouteName() == 'question_details'))
  <script type="text/javascript">
    $('.questions .arrowbox .like, .questions .arrowbox .dislike').click(function(e){
      e.preventDefault();
      var $this = $(this);
      $.get($(this).attr('href'),function($data){
        $this.parent('.arrowbox').next('.cntbox').find('.cntcount').text($data);
      }).fail(function(){
        alert('An error has been occurred, please try again later');
      });
    });
  </script>
@endif
```

在前面的代码中，我们检查用户是否登录，以及用户是否已经导航到索引或详细信息页面。然后我们使用 JavaScript 阻止用户点击链接，我们将点击事件改为 Ajax `get()`请求。在下一个代码中，我们将用结果填充投票值，该结果将来自`Ajax()`请求。

现在我们需要编写投票更新方法，使其正确工作。为此，在`app/controllers`下打开您的`QuestionsController.php`文件，并添加以下代码:

```php
/**
  * Vote AJAX Request
**/
public function getVote($direction,$id) {

  //request has to be AJAX Request
  if(Request::ajax()) {

    $question = Question::find($id);

    //if the question id is valid
    if($question) {

      //new vote count
      if($direction == 'up') {
        $newVote = $question->votes+1;
      } else {
        $newVote = $question->votes-1;
      }

      //now the update
      $update = $question->update(array(
        'votes' => $newVote
      ));

      //we return the new number
      return $newVote;
    } else {
      //question not found
      Response::make("FAIL", 400);
    }
  } else {
    return Redirect::route('index');
  }
}
```

`getVote()`方法检查问题是否有效，如果有效，则增加或减少一票。我们没有在这里验证参数`$direction`，因为我们已经在资源上使用正则表达式预过滤了`$direction`的值应该是`up`或者`down`。

### 注

在现实情况中，您甚至应该将投票存储在一个新表中，并检查用户的投票是否唯一。您还应该确保用户只投票一次。

现在我们的索引页面已经准备好并可以运行了，我们可以进行下一步了。

# 创建我们的问题页面

在详细信息页面中，我们需要向用户显示完整的问题。也将有一个地方的答案。要创建问题页面，我们执行以下步骤:

1.  First, we need to add the details method what we've defined on our route earlier. Add the following code to your `QuesionsController.php` file under `app/controllers`:

    ```php
    /**
     * Details page
    **/
    public function getDetails($id,$title) {
      //First, let's try to find the question:
      $question = Question::with('users','tags')->find($id);

      if($question) {

        //We should increase the "viewed" amount
        $question->update(array(
          'viewed' => $question->viewed+1
        ));

        return View::make('qa.details')
          ->with('title',$question->title)
          ->with('question',$question);

      } else {
        return Redirect::route('index')
        ->with('error','Question not found');
      }
    }
    ```

    我们首先尝试使用标签和提问者的信息来获取问题信息。如果找到问题，我们将视图计数增加一，我们只需加载视图，并将标题和问题信息添加到视图中。

2.  在显示视图之前，我们首先需要一些额外的路线来删除问题和回复帖子。要添加这些，请在`app`文件夹的`routes.php`文件中添加以下代码:

    ```php
    //Reply Question:
    Route::post('question/{id}/{title}',array('as'=>'question_reply','before'=>'csrf|user', 'uses'=>'AnswersController@postReply'))->where(array('id'=>'[0-9]+','title'=>'[0-9a-zA-Z\-\_]+'));

    //Admin Question Deletion
    Route::get('question/delete/{id}',array('as'=>'delete_question','before'=>'access_check:admin','uses'=>'QuestionsController@getDelete'))->where('id','[0-9]+');
    ```

3.  Now that the controller method and the routes required in the view are ready, we need the view to show the data to the end user. Follow the steps and add all the code provided further, by parts, to the `details.blade.php` file under `app/views/qa`:

    ```php
    @extends('template_masterpage')

    @section('content')

    <h1 id="replyh">{{$question->title}}</h1>
    <div class="qwrap questions">
      <div id="rcount">Viewed {{$question->viewed}} time{{$question->viewed>0?'s':''}}.</div>

      @if(Sentry::check())
        <div class="arrowbox">
          {{HTML::linkRoute('vote',''array('up',$question->id),array('class'=>'like', 'title'=>'Upvote'))}}
          {{HTML::linkRoute('vote','',array('down',$question->id),array('class'=>'dislike','title'=>'Downvote'))}}
        </div>
      @endif

      {{-- class will differ on the situation --}}
      @if($question->votes > 0)
        <div class="cntbox cntgreen">
      @elseif($question->votes == 0)
        <div class="cntbox">
      @else
        <div class="cntbox cntred">
      @endif
          <div class="cntcount">{{$question->votes}}</div>
          <div class="cnttext">vote</div>
        </div>
    ```

    在视图的第一部分，我们将视图文件扩展到我们的主页`template_masterpage`。然后我们开始填充`content`部分的代码。我们使用命名路由创建了两个链接，用于向上投票和向下投票，这将使用 Ajax 处理。此外，由于我们对每个投票州有不同的风格(绿色代表赞成票，红色代表反对票)，我们使用了`if`条款并修改了开头的`<div>`标签。

4.  Now add the following code to `details.blade.php`:

    ```php
      <div class="rblock">
        <div class="rbox">
          <p>{{nl2br($question->question)}}</p>
        </div>
        <div class="qinfo">Asked by <a href="#">{{$question->users->first_name.' '.$question->users->last_name}}</a> around {{date('m/d/Y H:i:s',strtotime($question->created_at))}}</div>

        {{--if the question has tags, show them --}}
        @if($question->tags!=null)
          <ul class="qtagul">
            @foreach($question->tags as $tag)
              <li>{{HTML::linkRoute('tagged',$tag->tag,$tag->tagFriendly)}}</li>
            @endforeach
          </ul>
        @endif
    ```

    在本节中，我们将展示问题本身，并检查是否有标签。如果`tags`对象不为空(标签存在)，我们为每个标签创建一个带有命名路线的链接，以显示用`$tag`标记的问题。

5.  Now add the following code to `details.blade.php`:

    ```php
        {{-- if the user/admin is logged in, we will have a buttons section --}}
        @if(Sentry::check())
          <div class="qwrap">
            <ul class="fastbar">
              @if(Sentry::getUser()->hasAccess('admin'))
                <li class="close">{{HTML::linkRoute('delete_question','delete',$question->id)}}</li>
              @endif
              <li class="answer"><a href="#">answer</a></li>
            </ul>
          </div>
        @endif
      </div>
      <div id="rreplycount">{{count($question->answers)}} answers</div>
    ```

    在本节中，如果最终用户是管理员，我们将显示回答和删除问题的按钮。

6.  Now add the following code to `details.blade.php`:

    ```php
      {{-- if it's a user, we will also have the answer block inside our view--}}
      @if(Sentry::check())
        <div class="rrepol" id="replyarea" style="margin-bottom:10px">
          {{Form::open(array('route'=>array('question_reply',$question->id,Str::slug($question->title))))}}
          <p class="minihead">Provide your Answer:</p>
          {{Form::textarea('answer',Input::old('answer'),array('class'=>'fullinput'))}}
          {{Form::submit('Answer the Question!')}}
          {{Form::close()}}
        </div>
      @endif

    </div>
    @stop
    ```

    在本节中，我们将为问题本身添加回答块，受益于 Laravel 4 的内置`Form`类。此表单仅适用于登录用户(以及管理员，因为他们也是登录用户)。我们使用`@stop`完成章节内容。

7.  Now add the following code to `details.blade.php`:

    ```php
    @section('footer_assets')

      {{--If it's a user, hide the answer area and make a simple show/hide button --}}
      @if(Sentry::check())
        <script type="text/javascript">

        var $replyarea = $('div#replyarea');
        $replyarea.hide();

        $('li.answer a').click(function(e){
          e.preventDefault();

          if($replyarea.is(':hidden')) {
            $replyarea.fadeIn('fast');
          } else {
            $replyarea.fadeOut('fast');
          }
        });
        </script>
      @endif

      {{-- If the admin is logged in, make a confirmation to delete attempt --}}
      @if(Sentry::check())
        @if(Sentry::getUser()->hasAccess('admin'))
          <script type="text/javascript">
          $('li.close a').click(function(){
            return confirm('Are you sure you want to delete this? There is no turning back!');
          });
          </script>
        @endif
      @endif
    @stop
    ```

    在这一部分，我们填充`footer_assets`部分添加一些 JavaScript，向用户显示/隐藏答案字段，在删除问题之前会向管理员显示一个确认框。

如果执行了所有步骤，您应该会看到如下截图所示的视图:

![Creating our questions page](graphics/2111OS_08_08.jpg)

最后，我们需要一个方法来删除这个问题。在`app/controllers`下的`QuestionsController.php`文件中添加以下代码:

```php
/**
 * Deletes the question
**/

public function getDelete($id) {
  //First, let's try to find the question:
  $question = Question::find($id);

  if($question) {
    //We delete the question directly
    Question::delete();
    //We won't have to think about the tags and the answers,
    //because they are set as foreign key and we defined them cascading on deletion, 
    //they will be automatically deleted

    //Let's return to the index page with a success message
    return Redirect::route('index')
      ->with('success','Question deleted successfully!');
  } else {
    return Redirect::route('index')
      ->with('error','Nothing to delete!');
  }
}
```

由于我们已经将相关表格设置为删除时级联，因此在删除问题时，我们不必担心删除答案和标签。

现在我们已经准备好发布答案，我们应该创建答案表并处理我们的答案。

# 创建我们的答案表和资源

我们的答案表会和现在的问题表非常相似，只是列数会少一些。我们的答案也可以被投票，并且答案可以被问题的提问者或管理员标记为最佳答案。要创建我们的答案表和资源，我们执行以下步骤:

1.  首先，让我们创建数据库表。在终端运行以下命令:

    ```php
    php artisan migrate:make create_answers_table --table=answers --create

    ```

2.  现在，打开在`app/database/migrations`下创建的迁移，用以下代码替换`up()`函数的内容:

    ```php
    Schema::create('answers', function(Blueprint $table)
    {
      $table->increments('id');

      //question's id
      $table->integer('questionID')->unsigned()->default(0);
      //answerer's user id
      $table->integer('userID')->unsigned()->default(0);
      $table->text('answer');
      //if the question's been marked as correct
      $table->enum('correct',array('0','1'))->default(0);
      //total number of votes:
      $table->integer('votes')->default(0);
      //foreign keys
      $table->foreign('questionID')->references('id')->on('questions')->onDelete('cascade');
      $table->foreign('userID')->references('id')->on('users')->onDelete('cascade');

      $table->timestamps();
    });
    ```

3.  Now, to benefit from the Eloquent ORM and its relations, we need a model for the `answers` table. Add the following code as `Answer.php` under `app/models`:

    ```php
    <?php

    class Answer extends Eloquent {

      //The relation with users
      public function users() {
        return $this->belongsTo('User','userID');
      }

      //The relation with questions
      public function questions() {
        return $this->belongsTo('Question','questionID');
      }

      //which fields can be filled
      protected $fillable = array('questionID', 'userID', 'answer', 'correct', 'votes');

      //Answer Form Validation Rules
      public static $add_rules = array(
        'answer'	=> 'required|min:10'
      );

    }
    ```

    答案是用户和问题的孩子，这就是为什么在我们的模型中，我们应该为用户和问题使用`belongsTo()`来关联他们的表。

4.  由于一个问题可能有多个答案，所以我们还应该从`questions`表到`answers`表添加一个关系(以获得关于您的问题的答案、您的问题的所有答案或我的所有投票问题的答案的数据)。为此，请在`app/models`下打开您的`Question.php`文件，并添加以下代码:

    ```php
    public function answers() {
      return $this->hasMany('Answer','questionID');
    }
    ```

5.  Finally, we need a controller to process the requests related to answers. Run the following command in the terminal to make a controller for the answers:

    ```php
    php artisan controller:make AnswersController

    ```

    该命令将在`app/controllers`下创建一个文件`AnswersController.php`。

现在我们的答案资源已经准备好了，我们可以处理答案了。

## 处理答案

在前面的部分，我们成功地创建了一个带有标签的问题，以及我们的答案表单。我们现在必须处理答案并将它们添加到数据库中。有一些简单的步骤可以遵循:

1.  First, we need the controller form to process the answers and add them to the table. To do this, open your freshly created `AnswersController.php` file under `app/controllers`, remove every autogenerated method inside the class, and add the following code inside the class definition:

    ```php
    /**
     * Adds a reply to the questions
    **/
    public function postReply($id,$title) {

      //First, let's check if the question id is valid
      $question = Question::find($id);

      //if question is found, we keep on processing
      if($question) {

        //Now let's run the form validation
        $validation = Validator::make(Input::all(), Answer::$add_rules);

        if($validation->passes()) {

          //Now let's create the answer
          Answer::create(array('questionID' => $question->id,'userID' => Sentry::getUser()->id,'answer' => Input::get('answer')
          ));

          //Finally, we redirect the user back to the question page with a success message
          return Redirect::route('question_details',array($id,$title))
            ->with('success','Answer submitted successfully!');

        } else {
          return Redirect::route('question_details',array($id,$title))
            ->withInput()
            ->with('error',$validation->errors()->first());
        }

      } else {
        return Redirect::route('index')
          ->with('error','Question not found');
      }

    }
    ```

    `postReply()`方法只是检查问题是否有效，运行表单验证，将问题和用户拥有的答案添加到数据库中，并将用户返回到问题页面。

2.  现在在问题页面，我们还需要包括答案和答案数量。但在那之前，我们需要把它们拿来。有一些步骤可以做到这一点。
    1.  First, open your `QuestionsController.php` file under `app/controllers`, and find the following line:

        ```php
               $question = Question::with('users','tags')->find($id);
        ```

        将前一行替换为后一行:

        ```php
               $question = Question::with('users','tags','answers')->find($id);
        ```

    2.  Now, find the following line in the `MainController.php` file under `app/controllers`, and find this line:

        ```php
              ->with('questions',Question::with('users','tags')-> orderBy('id','desc')->paginate(2));
        ```

        将前一行替换为后一行:

        ```php
             ->with('questions',Question::with('users', 'tags', 'answers')->orderBy('id','desc')->paginate(2));
        ```

    3.  Now open your `index.blade.php` file under `app/views/qa`, and find the following code:

        ```php
              {{--Answer section will be filled later in this chapter--}}
              <div class="cntbox">
                <div class="cntcount">0</div>
                <div class="cnttext">answer</div>
              </div>
        ```

        用以下代码替换以前的代码:

        ```php
               <?php
               //does the question have an accepted answer?
               $answers = $question->answers; 
               $accepted = false; //default false

               //We loop through each answer, and check if there is an accepted answer
               if($question->answers!=null) {
                 foreach ($answers as $answer) {
                   //If an accepted answer is found, we break       the loop
                   if($answer->correct==1) {
                     $accepted=true;
                     break;
                   }
                 }
               }
               ?>
               @if($accepted)
                 <div class="cntbox cntgreen">
               @else
                 <div class="cntbox cntred">
               @endif
                 <div class="cntcount">{{count($answers)}}</div>
                 <div class="cnttext">answer</div>
               </div>
        ```

        在这次修改中，我们添加了一个 PHP 代码和一个循环，检查每个答案是否被接受。如果是，我们改变`div`持有者等级。我们还增加了一个功能来显示答案的数量。

3.  接下来，我们需要定义路由资源来回答向上投票和向下投票，并选择最佳答案。将以下代码添加到`app`文件夹下的`routes.php`文件中:

    ```php
           //Answer upvoting and Downvoting
           Route::get('answer/vote/{direction}}/{id}',array('as'=>'vote_answer', 'before'=>'user', 'uses'=>'AnswersController@getVote'))->where(array('direction'=>'(up|down)', 'id'=>'[0-9]+'));
    ```

4.  现在，我们需要在问题详细信息页面中显示答案，以便用户可以看到答案。为此，打开`app/views/qa`下的`details.blade.php`文件，并执行以下步骤:
    1.  First, find the following line:

        ```php
               <div id="rreplycount">0 answers</div>
        ```

        将前一行替换为后一行:

        ```php
               <div id="rreplycount">{{count($question->answers)}} answers</div>
        ```

    2.  Now find the following code:

        ```php
               </div>
               @stop

               @section('footer_assets')
        ```

        在前面的代码上添加以下代码:

        ```php
               @if(count($question->answers))
                 @foreach($question->answers as $answer)

                   @if($answer->correct==1)
                     <div class="rrepol correct">
                   @else
                     <div class="rrepol">
            @endif
                   @if(Sentry::check())
                     <div class="arrowbox">
                       {{HTML::linkRoute('vote_answer','',array('up', $answer->id),array('class'=>'like', 'title'=>'Upvote'))}}
                       {{HTML::linkRoute('vote_answer','', array('down',$answer->id), array('class'=>'dislike','title'=>'Downvote'))}}

                     </div>
                   @endif

                   <div class="cntbox">
                     <div class="cntcount">{{$answer->votes}}</div>
                     <div class="cnttext">vote</div>
                   </div>

                   @if($answer->correct==1)
                     <div class="bestanswer">best answer</div>
                   @else
                     {{-- if the user is admin or the owner of the question, show the best answer button --}}
                     @if(Sentry::check())
                       @if(Sentry::getUser()->hasAccess('admin') || Sentry::getUser()->id == $question->userID)
                           <a class="chooseme" href="{{URL::route('choose_answer',$answer->id)}}"><div class="choosebestanswer">choose</div></a>
                       @endif
                     @endif
                   @endif
                   <div class="rblock">
                     <div class="rbox">
                       <p>{{nl2br($answer->answer)}}</p>
                     </div>
                     <div class="rrepolinf">
                     <p>Answered by <a href="#">{{$answer->users->first_name.' '.$answer->users->last_name}}</a> around {{date('m/d/Y H:i:s',strtotime($answer->created_at))}}</p>
                     </div>
                   </div>
                 </div>
                 @endforeach
               @endif
        ```

        目前的答案结构非常接近我们在本章前面创建的问题结构。此外，我们有一个按钮来选择最佳答案，它只显示给问题的提出者和管理员。

    3.  现在，我们需要在同一个视图中有一个确认按钮。为此，在`footer_assets`部分添加以下代码:

        ```php
               {{-- for admins and question owners --}}
               @if(Sentry::check())
                 @if(Sentry::getUser()->hasAccess('admin') || Sentry::getUser()->id == $question->userID)
                   <script type="text/javascript">
                     $('a.chooseme').click(function(){
                       return confirm('Are you sure you want to choose this answer as best answer?');
                     });
                   </script>
                 @endif
               @endif
        ```

5.  现在，我们需要一种方法来增加或减少答案的投票。将以下代码添加到`app/controllers`下的`AnswersController.php`文件中:

    ```php
    /**
      * Vote AJAX Request
    **/
    public function getVote($direction, $id) {

      //request has to be AJAX Request
      if(Request::ajax()) {
        $answer = Answer::find($id);
        //if the answer id is valid
        if($answer) {
          //new vote count
          if($direction == 'up') {
            $newVote = $answer->votes+1;
          } else {
            $newVote = $answer->votes-1;
          }

          //now the update
          $update = $answer->update(array(
            'votes' => $newVote
          ));

          //we return the new number
          return $newVote;
        } else {
          //answer not found
          Response::make("FAIL", 400);
        }
      } else {
        return Redirect::route('index');
      }
    }
    ```

`getVote()`方式与问题投票方式完全相同。这里唯一的区别是，不是问题，而是答案受到影响。

## 选择最佳答案

我们需要一种处理方法来选择一个选中的答案作为最佳答案。为了选择最佳答案，我们执行以下步骤:

1.  Open your `AnswersController.php` file under `app/controllers`, and add the following code:

    ```php
    /**
      * Chooses a best answer
    **/
    public function getChoose($id) {

      //First, let's check if there is an answer with that given ID
      $answer = Answer::with('questions')->find($id);

      if($answer) {
        //Now we should check if the user who clicked is an admin or the owner of the question 
        if(Sentry::getUser()->hasAccess('admin') || $answer->userID == Sentry::getUser()->id) {
            //First we should unmark all the answers of the question from correct (1) to incorrect (0)
            Answer::where('questionID',$answer->questionID)
              ->update(array(
                'correct' => 0
              ));

            //And we should mark the current answer as correct/best answer
          $answer->update(array(
            'correct' => 1
          ));

          //And now let's return the user back to the questions page
          return Redirect::route('question_details',array($answer->questionID, Str::slug($answer->questions->title)))
              ->with('success','Best answer chosen successfully');
        } else {
          return Redirect::route('question_details',array($answer->questionID, Str::slug($answer->questions->title)))
            ->with('error','You don\'t have access to this attempt!');
        }

      } else {
        return Redirect::route('index')
          ->with('error','Answer not found');
      }

    }
    ```

    在之前的代码中，我们首先检查答案是否为有效答案。然后，我们检查点击**最佳答案**按钮的用户是问题的提出者还是应用程序的管理员。之后，我们将该问题的所有答案标记为未选中(我们会删除该问题答案的所有最佳答案信息)，并将选择的答案标记为最佳答案。最后，我们返回带有成功消息的表单。

2.  现在，我们需要一种删除答案的方法。为此，首先我们需要一条路线。在`app`下打开您的`routes.php`文件，并添加以下代码:

    ```php
    //Deleting an answer
    Route::get('answer/delete/{id}',array('as'=>'delete_answer','before'=>'user', 'uses'=> 'AnswersController@getDelete'))->where('id','[0-9]+');
    ```

3.  Next, find the following code in the `details.blade.php` file under `app/views/qa`:

    ```php
    <p>Answered by <a href="#">{{$answer->users->first_name.' '.$answer->users->last_name}}</a> around {{date('m/d/Y H:i:s',strtotime($answer->created_at))}}</p>
    ```

    在前一个代码下面添加以下代码:

    ```php
    {{-- Only the answer's owner or the admin can delete the answer --}}
    @if(Sentry::check())
      <div class="qwrap">
        <ul class="fastbar">
          @if(Sentry::getUser()->hasAccess('admin') || Sentry::getUser()->id == $answer->userID)
            <li class="close">{{HTML::linkRoute('delete_answer','delete',$answer->id)}}</li>
          @endif
        </ul>
      </div>
    @endif
    ```

4.  现在，我们需要控制器方法来删除一个答案。将以下代码添加到`app/controllers`下的`AnswersController.php`文件中:

    ```php
    /**
     * Deletes an answer
    **/
    public function getDelete($id) {

      //First, let's check if there is an answer with that given ID
      $answer = Answer::with('questions')->find($id);

      if($answer) {
        //Now we should check if the user who clicked is an admin or the owner of the question 
        if(Sentry::getUser()->hasAccess('admin') || $answer->userID==Sentry::getUser()->id) {

          //Now let's delete the answer
          $delete = Answer::find($id)->delete();

          //And now let's return the user back to the questions page
          return Redirect::route('question_details',array($answer->questionID, Str::slug($answer->questions->title)))
            ->with('success','Answer deleted successfully');
        } else {
          return Redirect::route('question_details',array($answer->questionID, Str::slug($answer->questions->title)))
            ->with('error','You don\'t');
        }

      } else {
        return Redirect::route('index')
          ->with('error','Answer not found');
      }
    }
    ```

如果您已经正确完成了的所有操作，我们的详细信息页面的最终版本将如下图所示:

![Choosing the best answer](graphics/2111OS_08_09.jpg)

现在一切都准备好提问、回答、标记最佳答案、删除，在我们的应用中只缺少了一件事，标签搜索。如您所知，我们已经将所有标签作为链接，因此我们现在应该处理它们的路线。

# 通过标签搜索问题

在我们的主页和详细信息页面中，我们已经给所有的标签一个特殊的链接。我们将执行以下步骤按标签搜索问题:

1.  First, open your `QuestionsController.php` file under `app/controllers`, and add the following code:

    ```php
    /**
      * Shows the questions tagged with $tag friendly URL
    **/
    public function getTaggedWith($tag) {

      $tag = Tag::where('tagFriendly',$tag)->first();

      if($tag) {
        return View::make('qa.index')
          ->with('title','Questions Tagged with: '.$tag->tag)
          ->with('questions',$tag->questions()->with('users','tags','answers')->paginate(2));
      } else {
        return Redirect::route('index')
          ->with('error','Tag not found');
      }
    }
    ```

    这个代码所做的是，它首先使用列`tagFriendly`搜索一个标签，这给出了一个唯一的结果。所以，我们可以使用`first()`安全地返回第一个结果。然后我们检查标签是否存在于我们的系统中。如果没有，我们将用户返回到索引页面，并显示一条错误消息，指出尚未找到标记。

    如果找到了标签，使用我们定义的关系，我们会捕获所有使用该标签标记的问题，并使用急切加载来加载用户、标签(问题的所有标签)和答案(虽然我们没有在此页面上显示答案，但我们需要它们的计数来将其显示在页面上)。我们的视图将与索引页的视图完全相同。因此，我们没有创建新的视图，而是直接使用了该视图。

    我们将分页限制保持在两个，只是为了证明它是有效的。

2.  Finally, to allow JavaScript assets on the page (such as enabling Ajax upvoting and downvoting), open your `template_masterpage.php` file under `app/views`, and find the following line:

    ```php
    @if(Sentry::check() && (Route::currentRouteName() == 'index' || Route::currentRouteName() == 'question_details'))
    ```

    用以下代码替换以前的代码:

    ```php
    @if(Sentry::check() && (Route::currentRouteName() == 'index' || Route::currentRouteName() == 'tagged' || Route::currentRouteName() == 'question_details'))
    ```

这样，我们甚至允许这些 Ajax 事件出现在路径名为`tagged`的页面上。

如果您已经正确完成了的所有操作，并且如果您点击了一个标签的名称，将会出现如下页面:

![Searching questions by the tags](graphics/2111OS_08_10.jpg)

# 总结

在本章中，我们使用了 Laravel 4 的各种特性。我们已经学会移除公共部分，让 Laravel 在一些共享托管解决方案上发挥作用。我们还学习了 Sentry 2 的基础知识，Sentry 2 是一个强大的身份验证类。我们已经学习了如何使用多对多关系和数据透视表。我们还使用了属于和拥有任何关系。我们使用资源定义了我们所有的网址、表单动作和与路由的链接。所以如果你需要改变应用的 URL 结构(假设你需要把你的网站改成德语，问题的德语是 frage)，你只需要编辑`routes.php`。这样，您就不必挖掘每个文件来修复链接。我们使用分页类来浏览记录，我们还使用了 Laravel 表单生成器类。

在下一章中，我们将利用到目前为止所学的一切，开发一个功能齐全的电子商务网站。