# 用 Vue 路由器构建多页面应用

在最后一章中，我们了解了 Vue.js 组件，并将 Vuebnb 转换为基于组件的架构。现在我们已经做到了这一点，我们可以使用 Vue Router 轻松地在我们的应用程序中添加新页面。

在这一章中，我们将为 Vuebnb 创建一个主页，包括一个展示全套模拟列表的可点击缩略图库。

本章涵盖的主题:

*   解释什么是路由器库，为什么它们是单页应用程序的关键部分
*   Vue 路由器及其主要特性概述
*   Vue 路由器的安装和基本配置
*   使用`RouterLink`和`RouterView`特殊组件管理页面导航
*   使用 Vue 设置 AJAX，在不刷新页面的情况下从 web 服务中检索数据
*   在加载新页面之前，使用路线导航守卫检索数据

# 单页应用程序

大多数网站都被分成页面，以使它们包含的信息更容易消费。传统上，这是通过服务器/客户端模型来完成的，其中每个页面都必须用不同的网址从服务器加载。要导航到新页面，浏览器必须向该页面的网址发送请求。服务器会将数据发回，浏览器可以卸载现有页面并加载新页面。对于一般的互联网连接，这个过程可能需要几秒钟，在此期间，用户必须等待新页面加载。

通过使用一个强大的前端框架和一个 AJAX 实用程序，一个不同的模型是可能的:浏览器可以加载一个初始网页，但是导航到新的网页将不需要浏览器卸载该网页并加载一个新的网页。相反，新页面所需的任何数据都可以用 AJAX 异步加载。从用户的角度来看，这样的网站看起来会像其他网站一样有页面，但从技术角度来看，这个网站实际上只有一个页面。因此得名**单页应用** ( **SPA** )。

单页应用程序架构的优势在于，它可以为用户创造更无缝的体验。新页面的数据仍然必须被检索，因此会对用户的流程造成一些小的中断，但是这种中断被最小化，因为数据检索可以异步完成，并且 JavaScript 可以继续运行。此外，由于一些页面元素的重用，SPA 页面通常需要更少的数据，因此页面加载更快。

SPA 架构的缺点是，由于增加了功能，它使客户端应用程序变得更加庞大，因此用户必须在第一次页面加载时下载大型应用程序，这可能会抵消加速页面更改的收益。此外，处理路线增加了应用程序的复杂性，因为必须管理多个状态，必须处理网址，并且必须在应用程序中重新创建许多默认浏览器功能。

# 路由器

如果你采用 SPA 架构，并且你的应用程序设计包含多个页面，你会想要使用*路由器*。在这种情况下，路由器是一个库，它将通过 JavaScript 和各种本机 API 模拟浏览器导航，以便用户获得类似于传统多页应用程序的体验。路由器通常包括以下功能:

*   处理页面内的导航操作
*   将部分应用程序与路线匹配
*   管理地址栏
*   管理浏览器历史记录
*   管理滚动条行为

# 路由器视图

一些前端框架，如 Angular 或 Ember，包括一个现成的路由器库。指导这些框架的理念是，为开发人员的 SPA 提供完整、集成的解决方案会更好。

其他框架/库，如 React 和 Vue.js，不包括路由器。相反，您必须安装一个单独的库。

就 Vue.js 而言，有一个官方的路由器库叫做 *Vue Router* 。该库由 Vue.js 核心团队开发，因此针对 Vue.js 的使用进行了优化，并充分利用了 Vue 的基本特性，如组件和反应性。

使用 Vue Router，应用程序的不同*页面*由不同的组件表示。当您设置 Vue 路由器时，您将传入配置，告诉它哪些网址映射到哪个组件。然后，当点击应用程序中的链接时，Vue Router 将交换活动组件，以匹配新的网址，例如:

```
let routes = [
  { path: '/', component: HomePage },
  { path: '/about', component: AboutPage },
  { path: '/contact', component: ContactPage }
];
```

因为在正常情况下渲染一个组件几乎是一个即时的过程，所以使用 Vue Router 在页面之间的转换也是如此。但是，如果您的不同页面需要，可以调用异步钩子来为您提供从服务器加载新数据的机会。

# 专用附件

当您安装 Vue Router 时，有两个组件在全球注册，以便在整个应用程序中使用:`RouterLink`和`RouterView`。

`RouterLink`通常用于代替`a`标签，并让您的链接访问 Vue 路由器的特殊功能。

如前所述，Vue Router 将交换指定的页面组件，作为模拟浏览器导航的一种方式。`RouterView`是进行组件交换的出口。像一个槽，你把它放在你的主页模板的某个地方。例如:

```
<div id="app">
  <header></header>
  <router-view>
    // This is where different page components display
  </router-view>
  <footer></footer>
</div>
```

# vuebnb 路由

对于 Vuebnb 来说，成为单页应用程序从来都不是一个明确的目标。事实上，正如我们将在本书后面看到的，Vuebnb 将偏离纯 SPA 架构。

也就是说，合并 Vue Router 将非常有利于用户在应用中的导航体验，所以我们将在本章中将其添加到 Vuebnb 中。

当然，如果我们要添加路由器，我们需要一些额外的页面！到目前为止，在这个项目中，我们一直在开发 Vuebnb 的*列表*页面，但是还没有开始开发应用程序的首页。因此，除了安装 Vue Router 之外，我们还将在 Vuebnb 主页上开始工作，该主页将显示所有模拟列表的缩略图和链接:

![](assets/ecdce2d9-a3cb-45ea-81f0-2f653471205e.png)

Figure 7.1\. Front page of Vuebnb

# 安装 Vue 路由器

Vue 路由器是一个 NPM 软件包，可以安装在命令行上:

```
$  npm i --save-dev vue-router
```

让我们将路由器配置放入一个新文件中，`router.js`:

```
$ touch resources/assets/js/router.js
```

要将 Vue Router 添加到我们的项目中，我们必须导入库，然后使用`Vue.use` API 方法使 Vue 与 Vue Router 兼容。这将给 Vue 一个新的配置属性`router`，我们可以用它来连接一个新的路由器。

然后我们用新的`VueRouter()`创建一个 Vue 路由器的实例。

`resources/assets/js/router.js`:

```
import Vue from 'vue';
import VueRouter from 'vue-router';
Vue.use(VueRouter);

export default new VueRouter();
```

通过从这个新文件中导出我们的路由器实例，我们已经把它做成一个可以在`app.js`中导入的模块。如果我们将导入的模块命名为`router`，可以使用对象析构来简洁地将其连接到我们的主配置对象。

`resources/assets/js/app.js`:

```
import "core-js/fn/object/assign";
import Vue from 'vue';

import ListingPage from '../components/ListingPage.vue';
import router from './router'

var app = new Vue({
  el: '#app',
  render: h => h(ListingPage),
  router
});
```

# 创建路线

Vue Router 最基本的配置就是提供一个`routes`数组，将 URL 映射到对应的页面组件。该数组将包含至少具有两个属性的对象:`path`和`component`。

Note that by *page components* I'm simply referring to any components that we've designated to represent a page in our app. They are regular components in every other way.

目前，我们的应用程序中只有两条路线，一条用于我们的主页，一条用于我们的列表页面。`HomePage`组件还不存在，所以我们将保留它的路线注释，直到我们创建它。

`resources/assets/js/router.js`:

```
import ListingPage from '../components/ListingPage.vue';

export default new VueRouter({
  mode: 'history',
  routes: [
    // { path: '/', component: HomePage }, // doesn't exist yet!
    { path: '/listing/:listing', component: ListingPage }
  ]
});
```

您会注意到我们的`ListingPage`组件的路径包含一个动态线段`:listing`，因此该路径将匹配包括`/listing/1, listing/2 ... listing/whatever`在内的路径。

There are two modes for Vue Router: *hash* mode and *history* mode. Hash mode uses the URL hash to simulate a full URL so that the page won't be reloaded when the hash changes. History mode has *real* URLs and leverages the `history.pushState` API to change the URL without causing a page reload. The only downside to history mode is that URLs outside of the app, such as `/some/weird/path`, can't be handled by Vue and must be handled by the server. That's no problem for us, so we'll use history mode for Vuebnb.

# 应用组件

为了让我们的路由器工作，我们需要在页面模板的某个地方声明一个`RouterView`组件。否则，页面组件将无处可呈现。

为此，我们将稍微调整我们的应用程序。事实上，`ListingPage`组件是应用程序的`root`组件，因为它位于组件层次结构的顶部，并加载我们使用的所有其他组件。

由于我们希望路由器基于 URL 在`ListingPage`和`HomePage`之间切换，因此我们需要另一个组件在层次结构中位于`ListingPage`之上并处理这项工作。我们将这个新的根组件称为`App`:

![](assets/2a411013-4710-4909-ad18-255dd9144d45.png)

Figure 7.2\. The relationship between App, ListingPage, and HomePage

让我们创建`App`组件文件:

```
$ touch resources/assets/components/App.vue
```

Vue 的根实例应该在加载时将其呈现给页面，而不是`ListingPage`。

`resources/assets/js/app.js`:

```
import App from '../components/App.vue';

...

var app = new Vue({
  el: '#app',
  render: h => h(App),
  router
});
```

以下是`App`组件的内容。我已经将特殊的`RouterView`组件添加到模板中，这是`HomePage`或`ListingPage`组件将渲染的出口。

您还会注意到我已经将工具栏从`app.blade.php`移动到了`App`的模板中。这就是工具栏在 Vue 领域的原因；之前它在挂载点之外，因此不能被 Vue 接触到。我这样做是为了以后我们可以使用`RouterLink`将主标志链接到主页，因为这是大多数网站的惯例。我已经将任何工具栏相关的 CSS 也移到了`style`元素中。

`resources/assets/components/App.vue`:

```
<template>
  <div>
    <div id="toolbar">
      <img class="icon" src="/images/logo.png">
      <h1>vuebnb</h1>
    </div>
    <router-view></router-view>
  </div>
</template>
<style>
  #toolbar {
    display: flex;
    align-items: center;
    border-bottom: 1px solid #e4e4e4;
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
  }

  #toolbar .icon {
    height: 34px;
    padding: 16px 12px 16px 24px;
    display: inline-block;
  }

  #toolbar h1 {
    color: #4fc08d;
    display: inline-block;
    font-size: 28px;
    margin: 0;
  }
</style>
```

完成后，如果您现在将浏览器导航到类似`/listing/1`的网址，您将看到一切看起来都和以前一样。但是，如果您查看 Vue Devtools，您会看到组件层次结构发生了变化，反映出添加了`App`组件。

还有一个指示器，告诉我们`ListingPage`组件是 Vue 路由器的活动页面组件:

![](assets/41b25c67-0eeb-449c-8448-c7703091d149.png)

Figure 7.3. /listing/1 with Vue Devtools open, showing the component hierarchy

# 主页

让我们现在开始在主页上工作。我们将首先创建一个新组件`HomePage`:

```
$ touch resources/assets/components/HomePage.vue
```

现在，让我们在正确设置组件之前向组件添加占位符标记。

`resources/assets/components/HomePage.vue`:

```
<template>
  <div>Vuebnb home page</div>
</template>
```

请务必在`router`文件中导入该组件，并取消其使用路径的注释。

`resources/assets/js/router.js`:

```
....

import HomePage from '../components/HomePage.vue';
import ListingPage from '../components/ListingPage.vue';

export default new VueRouter({
  mode: 'history',
  routes: [
    { path: '/', component: HomePage },
    { path: '/listing/:listing', component: ListingPage }
  ]
});
```

You might be tempted to test this new route out by putting the URL `http://vuebnb.test/` into your browser address bar. You'll find, though, that it results in a 404 error. Remember, we still haven't created a route for this on our server. Although Vue is managing routes from *within* the app, any address bar navigation requests must be served from Laravel.

现在让我们使用`RouterLink`组件在工具栏中创建一个到我们主页的链接。这个组件就像一个增强的`a`标签。例如，如果你给你的路线一个`name`属性，你可以简单地使用`to`道具，而不是必须提供一个`href`。Vue 将在渲染时将其解析为正确的网址。

`resources/assets/components/App.vue`:

```
<div id="toolbar">
  <router-link :to="{ name: 'home' }">
    <img class="icon" src="/images/logo.png">
    <h1>vuebnb</h1>
  </router-link>
</div>
```

让我们也将名称属性添加到我们的路由中，这样就可以工作了。

`resources/assets/js/app.js`:

```
routes: [
  { path: '/', component: HomePage, name: 'home' },
  { path: '/listing/:listing', component: ListingPage, name: 'listing' }
]
```

我们现在还必须修改我们的 CSS，因为我们现在有另一个标签包裹着我们的标志。修改工具栏的 CSS 规则以匹配下面的规则。

`resources/assets/components/App.vue`:

```
<template>...</template>
<style>
  #toolbar {
    border-bottom: 1px solid #e4e4e4;
    box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
  }

  ...

  #toolbar a {
    display: flex;
    align-items: center;
    text-decoration: none;
  }
</style>
```

现在我们打开一个列表页面，比如`/listing/1`。如果你检查 DOM，你会看到我们的工具栏现在有一个新的`a`标签，里面有一个正确解析的链接回到主页:

![](assets/f53a1ca6-f0d5-4c08-b75c-c6f794e81b96.png)

Figure 7.4\. The toolbar is a link back to the home page via the RouterLink element

如果你点击那个链接，你会被带到主页！请记住，*页面*实际上并没有改变；Vue 路由器只是在`RouterView`内将`ListingPage`换成了`HomePage`，还通过`history.pushState` API 更新了浏览器 URL:

![](assets/4a5c5d24-13bb-45ea-8dac-a2272c4f7a4b.png)

Figure 7.5\. Home page with Vue Devtools showing component hierarchy

# 回家路线

现在，让我们为主页添加一个服务器端路由，这样我们就可以从根路径加载我们的应用程序。这条新路线将指向我们`ListingController`类中的一个`get_home_web`方法。

`routes/web.php`:

```
<?php

Route::get('/', 'ListingController@get_home_web');

Route::get('/listing/{listing}', 'ListingController@get_listing_web');
```

现在转到控制器，我们将使`get_home_web`方法返回`app`视图，就像它对列表 web 路由所做的那样。`app`视图包括一个模板变量模型，我们使用它来传递初始应用程序状态，如[第 5 章](05.html)、*中所设置的，将 Laravel 和 Vue.js 与 Webpack* 集成在一起。现在，只需分配一个空数组作为占位符。

`app/Http/Controllers/ListingController.php`:

```
public function get_home_web() 
{
  return view('app', ['model' => []]);
}
```

完成后，我们现在可以导航到`http://vuebnb.test/`，它将会工作！当 Vue 应用程序启动时，Vue 路由器将检查网址值，并看到路径为`*/*`，将加载`RouterView`插座内的`HomePage`组件，用于应用程序的第一次渲染。

查看此页面的来源，它与我们加载列表路线时得到的页面完全相同，因为它是相同的视图，即`app.blade.php`。唯一的区别是初始状态是一个空数组:

![](assets/c29df2f7-0487-481e-8df9-ffaac0b12063.png)

Figure 7.6\. Page source of vuebnb.test with empty initial state

# 初态

就像我们的列表页面一样，我们的主页需要初始状态。查看成品，我们可以看到主页显示了所有模拟列表的摘要，包括缩略图、标题和简短描述:

![](assets/bdfc15b5-27a5-4468-a68d-bd19e7a2ac25.png)

Figure 7.7\. Completed home page, focusing on listings

# 重构

在我们将初始状态注入主页之前，让我们对代码做一个小的重构，包括重命名一些变量和重组一些方法。这将确保代码语义反映不断变化的需求，并保持我们的代码可读且易于理解。

首先，让我们将模板变量从`$model`重命名为更通用的`$data`。

`resources/views/app.blade.php`:

```
<script type="text/javascript">
  window.vuebnb_server_data = "{!! addslashes(json_encode($data)) !!}"
</script>
```

在我们的清单控制器中，我们现在将把清单路由方法中的任何公共逻辑抽象成一个名为`get_listing`的新辅助方法。在这个辅助方法中，我们将把`Listing`模型嵌套在`listing`键下的`Collection`中。`Collection`是一个用于雄辩模型的类似数组的包装器，它提供了一系列方便的方法，我们将很快投入使用。`get_listing`将包含来自`add_image_urls`助手方法的逻辑，现在可以安全删除。

当我们调用`view`方法时，我们还需要反映模板变量的变化。

`app/Http/Controllers/ListingController.php`:

```
private function get_listing($listing)
{
  $model = $listing->toArray();
  for($i = 1; $i <=4; $i++) {
    $model['image_' . $i] = asset(
      'images/' . $listing->id . '/Image_' . $i . '.jpg'
    );
  }
  return collect(['listing' => $model]);
}

public function get_listing_api(Listing $listing)
{
  $data = $this->get_listing($listing);
  return response()->json($data);
}

public function get_listing_web(Listing $listing)
{
  $data = $this->get_listing($listing);
  return view('app', ['data' => $data]);
}

public function get_home_web()

```

```
{
  return view('app', ['data' => []]);
}

```

最后，我们需要更新我们的`ListingPage`组件，以反映我们正在注入的服务器数据的新名称和结构。

`resources/assets/components/ListingPage.vue`:

```
<script>
  let serverData = JSON.parse(window.vuebnb_server_data);
  let model = populateAmenitiesAndPrices(serverData.listing);

  ...
</script>
```

# 主页初始状态

使用雄辩的 ORM，使用方法`Listing::all`检索我们所有的列表条目是很简单的。这个方法在一个`Collection`对象中返回多个`Model`实例。

请注意，我们不需要模型上的所有字段，例如，`amenities`、`about`等不会在填充主页的列表摘要中使用。为了确保我们的数据尽可能精简，我们可以将一组字段传递给`Listing::all`方法，该方法将告诉数据库只包括那些明确提到的字段。

`app/Http/Controllers/ListingController.php`:

```
public function get_home_web() 
{
  $collection = Listing::all([
    'id', 'address', 'title', 'price_per_night'
  ]);
  $data = collect(['listings' => $collection->toArray()]);
  return view('app', ['data' => $data]);
}

/*
  [
    "listings" => [
      0 => [
        "id" => 1,
        "address" => "...",
        "title" => "...",
        "price_per_night" => "..."
      ]
      1 => [ ... ]
      ...
      29 => [ ... ]
    ]
  ]
*/
```

# 添加缩略图

每个模拟列表都有第一个图像的缩略图版本，可用于列表摘要。缩略图比我们用于列表页面标题的图像小得多，非常适合用于主页上的列表摘要。缩略图的网址是`public/images/{x}/Image_1_thumb.jpg`，其中`{x}`是列表的标识。

`Collection`对象有一个助手方法，`transform`，我们可以用它来给每个列表添加缩略图 URL。`transform`接受每个项目调用一次的回调闭包函数，允许您修改该项目并将其返回集合，而无需大惊小怪。

`app/Http/Controllers/ListingController.php`:

```
public function get_home_web() 
{
  $collection = Listing::all([
    'id', 'address', 'title', 'price_per_night'
  ]);
  $collection->transform(function($listing) {
    $listing->thumb = asset(
      'images/' . $listing->id . '/Image_1_thumb.jpg'
    );
    return $listing;
  });
  $data = collect(['listings' => $collection->toArray()]);
  return view('app', ['data' => $data]);
}

/*
  [
    "listings" => [
      0 => [
        "id" => 1,
        "address" => "...",
        "title" => "...",
        "price_per_night" => "...",
        "thumb" => "..."
      ]
      1 => [ ... ]
      ...
      29 => [ ... ]
    ]
  ]
*/
```

# 在客户端接收

现在初始状态准备好了，让我们将其添加到我们的`HomePage`组件中。在我们使用它之前，我们还需要考虑一个额外的方面:列表摘要按*国家*分组。再次查看*图 7.7* 查看这些组是如何显示的。

解析完注入的数据后，让我们修改对象，以便按国家对列表进行分组。我们可以很容易地创建一个函数来做到这一点，因为每个上市对象都有一个`address`属性，其中国家总是被明确命名，例如*台湾台北市万华区汉中街 51 号 108* 。

为了让你不用写这个函数，我在`helpers`模块中提供了一个名为`groupByCountry`的函数，可以在组件配置的顶部导入。

`resources/assets/components/HomePage.vue`:

```
...

<script>
  import { groupByCountry } from '../js/helpers';

  let serverData = JSON.parse(window.vuebnb_server_data);
  let listing_groups = groupByCountry(serverData.listings);

  export default {
    data() {
      return { listing_groups }
    }
  }
</script>
```

我们现在将通过 Vue Devtools 看到`HomePage`已成功加载列表摘要，按国家分组并准备显示:

![](assets/3936ccf7-bf87-4f1f-81b6-ba32cefb8c2c.png)

Figure 7.8\. Vue Devtools showing the state of the HomePage component

# 列表摘要组件

现在`HomePage`组件有了可用的数据，我们可以开始显示它了。

首先，清除组件的现有内容，并用`div`替换它。这个`div`将会有一个`v-for`指令来遍历我们的每个列表组。由于`listing_groups`是一个有键/值对的对象，我们给`v-for`两个别名:`group`和`country`，分别是每个对象项的值和键。

我们将在标题中插入`country`。`group`将在下一节中使用。

`resources/assets/components/HomePage.vue`:

```
<template>
  <div>
    <div v-for="(group, country) in listing_groups">
      <h1>Places in {{ country }}</h1>
      <div>
          Each listing will go here
      </div>
    </div>
  </div>
</template>
<script>...</script>

```

这就是主页现在的样子:

![](assets/858d9f59-82a4-4b37-9f17-d66fb6b3d5ee.png)

Figure 7.9\. Iterating the listing summary groups in the HomePage component

由于每个列表摘要都有些复杂，我们将创建一个单独的组件`ListingSummary`，用于显示它们:

```
$ touch resources/assets/components/ListingSummary.vue
```

让我们在`HomePage`模板中声明`ListingSummary`。我们将再次使用`v-for`指令来迭代`group`，一个数组，为每个成员创建一个新的`ListingSummary`实例。每个成员的数据将绑定到一个单独的道具`listing`。

`resources/assets/components/HomePage.vue`:

```
<template>
  <div>
    <div v-for="(group, country) in listing_groups">
      <h1>Places in {{ country }}</h1>
      <div class="listing-summaries">
        <listing-summary 
          v-for="listing in group" 
          :key="listing.id" 
          :listing="listing"
        ></listing-summary>
      </div>
    </div>
  </div>
</template>
<script>
  import { groupByCountry } from '../js/helpers';
  import ListingSummary from './ListingSummary.vue';

  let serverData = JSON.parse(window.vuebnb_server_data);
  let listing_groups = groupByCountry(serverData.listings);

  export default {
    data() {
      return { listing_groups }
    },
    components: {
      ListingSummary
    }
  }
</script>
```

让我们为`ListingSummary`组件创建一些简单的内容，只是为了测试我们的方法。

`resources/assets/components/ListingSummary.vue`:

```
<template>
  <div class="listing-summary">
    {{ listing.address }}
  </div>
</template>
<script>
  export default {
    props: [ 'listing' ],
  }
</script>
```

刷新我们的页面，我们现在将看到列表摘要的原型:

![](assets/914379fb-83ff-4ee2-9f2f-bf458f5c6cce.png)

Figure 7.10\. Prototype of ListingSummary component

既然这种方法有效，现在让我们完成`ListingSummary`组件的结构。为了显示缩略图，我们将其绑定为固定宽度/高度的背景图像`div`。我们还需要一些 CSS 规则来很好地显示这一点。

`resources/assets/components/ListingSummary.vue`:

```
<template>
  <div class="listing-summary">
    <div class="wrapper">
      <div class="thumbnail" :style="backgroundImageStyle"></div>
      <div class="info title">
        <span>{{ listing.price_per_night }}</span>
        <span>{{ listing.title }}</span>
      </div>
      <div class="info address">{{ listing.address }}</div>
    </div>
  </div>
</template>
<script>
  export default {
    props: [ 'listing' ],
    computed: {
      backgroundImageStyle() {
        return {
          'background-image': `url("${this.listing.thumb}")`
        }
      }
    }
  }
</script>
<style>
  .listing-summary {
    flex: 0 0 auto;
  }

  .listing-summary a {
    text-decoration: none;
  }

  .listing-summary .wrapper {
    max-width: 350px;
    display: block;
  }

  .listing-summary .thumbnail {
    width: 350px;
    height: 250px;
    background-size: cover;
    background-position: center;
  }

  .listing-summary .info {
    color: #484848;
    word-wrap: break-word;
    letter-spacing: 0.2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .listing-summary .info.title {
    padding-top: 5px;
    font-weight: 700;
    font-size: 16px;
    line-height: 24px;
  }

  .listing-summary .info.address {
    font-size: 14px;
    line-height: 18px;
  }
</style>
```

添加该代码后，您的列表摘要将如下所示:

![](assets/1d03bd54-26e4-4b89-96ba-488b7749ccc8.png)

Figure 7.11\. Complete listing summaries being displayed

我们给每个列表摘要一个固定的宽度/高度，这样我们可以在一个整洁的网格中显示它们。目前，它们显示在一个很高的列中，所以让我们向`HomePage`组件添加一些 CSS flex 规则，以将摘要分成行。

我们将向包装摘要的元素添加一个类`listing-summary-group`。我们还将向根`div`添加一个类`home-container`，以限制页面的宽度并使内容居中。

`resources/assets/components/HomePage.vue`:

```
<template>
  <div class="home-container">
    <div 
      v-for="(group, country) in listing_groups" 
      class="listing-summary-group"
    >
      ...
    </div>
  </div>
</template>
<script>...</script>
<style>
  .home-container {
    margin: 0 auto;
    padding: 0 25px;
  }

  @media (min-width: 1131px) {
    .home-container {
      width: 1080px;
    }
  }

  .listing-summary-group {
    padding-bottom: 20px;
  }

  .listing-summaries {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    overflow: hidden;
  }
  .listing-summaries > .listing-summary {
    margin-right: 15px;
  }
  .listing-summaries > .listing-summary:last-child {
```

```
    margin-right: 0;
  }
</style>
```

最后，我们需要添加一个规则来防止列表迫使文档的边缘超出视口。将此添加到主 CSS 文件中。

`resources/assets/css/style.css`:

```
html, body {
  overflow-x: hidden;
}
```

这样，我们就有了一个好看的主页:

![](assets/2af19583-0877-4a44-b9c5-44c1be1d91d5.png)

Figure 7.12\. Listing summaries in rows

您会注意到，在整个页面宽度上，我们只能看到每个国家组的三个列表。其他七个被 CSS `overflow: hidden`规则隐藏。很快，我们将为每个组添加图像滑块功能，以允许用户浏览所有列表。

# 应用内导航

如果我们使用浏览器的地址栏导航到主页`http://vuebnb.test/`，它会起作用，因为 Laravel 现在正在这条路线上提供一个页面。但是，如果我们从列表页面导航到主页*，就不再有任何页面内容:*

![](assets/4c4b9d22-86d4-4846-8b3d-3b5bb6f6ff55.png)

Figure 7.13\. Empty home page after navigating from listing page

我们目前没有从主页到列表页面的任何链接，但如果我们有，我们会遇到类似的问题。

原因是我们的页面组件目前从我们注入到文档头部的数据中获得它们的初始状态。如果我们使用不调用页面刷新的 Vue Router 导航到不同的页面，下一个页面组件将合并错误的初始状态。

我们需要改进我们的架构，以便当一个页面被导航到时，我们检查注入头部的模型是否与当前页面匹配。为了方便起见，我们将在模型中添加一个`path`属性，并检查它是否与活动的网址相匹配。如果没有，我们将使用 AJAX 从 web 服务中获取正确的数据:

![](assets/a22ae360-9d35-4247-b66a-1ae858d2130f.png)

Figure 7.14\. How a page decides what data it needs If you're interested in reading more about this design pattern, check out the article *Avoid This Common Anti-Pattern In Full-Stack Vue/Laravel Apps* at [https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/](https://vuejsdevelopers.com/2017/08/06/vue-js-laravel-full-stack-ajax/).

# 向模型添加路径

让我们转到列表控制器，向注入视图头部的数据添加一个`path`属性。为此，我们将添加一个名为`add_meta_data`的辅助函数，它将添加路径，以及后面章节中的一些其他元属性。

注意，当前路线的路径可以由`Request`对象确定。该对象可以被声明为任何`route-handling`函数的最后一个参数，并由服务容器在每个请求中提供。

`app/Http/Controllers/ListingController.php`:

```
...

private function add_meta_data($collection, $request)
{
  return $collection->merge([
    'path' => $request->getPathInfo()
  ]);
}

public function get_listing_web(Listing $listing, Request $request)
{
  $data = $this->get_listing($listing);
  $data = $this->add_meta_data($data, $request);
  return view('app', ['data' => $data]);
}

public function get_home_web(Request $request)
{
  $collection = Listing::all([
    'id', 'address', 'title', 'price_per_night'
  ]);
  $collection->transform(function($listing) {
    $listing->thumb = asset(
      'images/' . $listing->id . '/Image_1_thumb.jpg'
    );
    return $listing;
  });
  $data = collect(['listings' => $collection->toArray()]);
  $data = $this->add_meta_data($data, $request);
  return view('app', ['data' => $data]);
}

/*
  [
    "listings" => [ ... ],
    "path" => "/"
  ]
*/
```

# 路线导航警卫

与生命周期挂钩类似，*导航条*允许您在 Vue Router 的生命周期中的特定点拦截它们的导航。这些防护可以应用于特定组件、特定路线或所有路线。

例如，`afterEach`是导航离开任何路线后调用的导航守卫。您可以使用这个钩子来存储分析信息，例如:

```
router.afterEach((to, from) => {
  storeAnalytics(userId, from.path);
})
```

如果头部的数据不合适，我们可以使用`beforeRouteEnter`导航守卫从我们的网络服务中获取数据。考虑下面的伪代码，了解我们如何实现这一点:

```
beforeRouteEnter(to, from, next) {
  if (to !== injectedData.path) {
    getDataWithAjax.then(data => {
      applyData(data)
    })
  } else {
    applyData(injectedData)
  }
  next()
}
```

# 然后

导航仪的一个重要特点是，在调用`next`功能之前，会暂停导航。这允许在解析导航之前执行异步代码:

```
beforeRouteEnter(to, from, next) {
  new Promise(...).then(() => {
    next();  
  });
}
```

可以通过`false`到`next`功能阻止导航，也可以通过不同的路线重定向。如果您没有通过任何测试，导航将被视为已确认。

`beforeRouteEnter`守卫是特例。首先，`this`在其中是未定义的，因为它是在创建下一个页面组件之前调用的:

```
beforeRouteEnter(to, from, next) {
  console.log(this); // undefined
}
```

但是`beforeRouteEnter`中的`next`函数可以接受回调函数作为参数，例如`next(component => { ... });`，其中`component`是页面组件实例。

在确认路由并创建组件实例之前，不会触发此回调。由于 JavaScript 闭包是如何工作的，回调可以访问调用它的周围代码的范围:

```
beforeRouteEnter(to, from, next) {
  var data = { ... }
  next(component => {
    component.$data = data;
  });
}
```

# 主页组件

让我们将`beforeRouteEnter`添加到`HomePage`组件中。首先，将用于从文档头检索数据的任何逻辑移到钩子中。然后我们检查数据的`path`属性，看它是否匹配当前路线。如果是这样，我们调用`next`并传递一个回调函数，将数据应用到组件的实例中。如果没有，我们将需要使用 AJAX 来获得正确的数据。

`resources/assets/components/HomePage.vue`:

```
export default {
  data() {
    return {
      listing_groups: []
    };
  },
  components: {
    ListingSummary
  },
  beforeRouteEnter(to, from, next) {
    let serverData = JSON.parse(window.vuebnb_server_data);
    if (to.path === serverData.path) {
      let listing_groups = groupByCountry(serverData.listings);
      next(component => component.listing_groups = listing_groups);
    } else {
      console.log('Need to get data with AJAX!')
      next(false);
    }
  }
}
```

I've added `listing_groups` as a data property. Before, we were applying our data to the component instance as it was created. Now, we're applying the data after the component is created. To set up reactive data, Vue must know the names of the data properties, so we initialize with an empty value and update it when the data needed is available.

# 主应用编程接口端点

我们现在将实现 AJAX 功能。然而，在此之前，我们需要向我们的 web 服务添加一个主页端点。

让我们首先添加 home API 路由。

`routes/api.php`:

```
...

Route::get('/', 'ListingController@get_home_api');
```

现在看一下`ListingController`类，我们将把大部分逻辑从`get_home_web`抽象成一个新的函数，`get_listing_summaries`。然后我们将在`get_home_api`方法中使用这个函数，并返回一个 JSON 响应。

`app/Http/Controllers/ListingController.php`:

```
private function get_listing_summaries()
{
  $collection = Listing::all([
    'id', 'address', 'title', 'price_per_night'
  ]);
  $collection->transform(function($listing) {
    $listing->thumb = asset(
      'images/' . $listing->id . '/Image_1_thumb.jpg'
    );
    return $listing;
  });
  return collect(['listings' => $collection->toArray()]);
}

public function get_home_web(Request $request)
{
  $data = $this->get_listing_summaries();
  $data = $this->add_meta_data($data, $request);
  return view('app', ['data' => $data]);
}

public function get_home_api()
{
  $data = $this->get_listing_summaries();
  return response()->json($data);
}
```

# 阿克斯

为了对 web 服务执行 AJAX 请求，我们将使用 Axios HTTP 客户端，它包含在 Laravel 的默认前端代码中。Axios 有一个非常简单的应用编程接口，允许我们像这样请求一个获取网址:

```
axios.get('/my-url');
```

Axios 是一个基于 Promise 的库，因此为了检索响应，您可以简单地链接一个`then`回调:

```
axios.get('/my-url').then(response => {
  console.log(response.data); // Hello from my-url
});
```

由于已经安装了 Axios NPM 软件包，我们可以继续导入`HomePage`组件。然后，我们可以使用它来执行对主应用编程接口端点`/api/`的请求。在`then`回调中，我们将返回的数据应用于组件实例，就像我们对内联模型所做的那样。

`resources/assets/components/HomePage.vue`:

```
...
import axios from 'axios';

export default {
  data() { ... },
  components: { ... },
  beforeRouteEnter (to, from, next) {
    let serverData = JSON.parse(window.vuebnb_server_data);
    if (to.path === serverData.path) {
      let listing_groups = groupByCountry(serverData.listings);
      next(component => component.listing_groups = listing_groups);
    } else {
      axios.get(`/api/`).then(({ data }) => {
        let listing_groups = groupByCountry(data.listings);
        next(component => component.listing_groups = listing_groups);
      });
    }
  }
}
```

这样，我们现在可以通过两种方式导航到主页，要么通过地址栏，要么通过列表页面的链接。不管怎样，我们得到了正确的数据！

# Mixins

如果您有任何组件之间通用的功能，您可以将其放在`mixin`中，以避免重写相同的功能。

Vue `mixin`是一个与组件配置对象形式相同的对象。要在组件中使用它，请在数组中声明并将其分配给配置属性`mixin`。当这个组件被实例化时，`mixin`的任何配置选项将与您在组件上声明的内容合并:

```
var mixin = {
  methods: {
    commonMethod() {
      console.log('common method');
    }
  }
};

Vue.component('a', {
  mixins: [ mixin ]
});

Vue.component('b', {
  mixins: [ mixin ]
  methods: {
    otherMethod() { ... }
  }
});
```

您可能想知道如果组件配置有一个方法或其他属性与`mixin`冲突会发生什么。答案是`mixins`有一个*合并策略*，它决定了任何冲突的优先级。通常，组件的指定配置将优先。http://vuejs.org的 Vue.js 文档中解释了合并策略的细节。

# 将解决方案移动到混合模式

让我们将获取正确数据的解决方案推广到主页，这样我们也可以在列表页面上使用它。为此，我们将把 Axios 和`beforeRouteEnter`挂钩从`HomePage`组件移动到一个 mixin 中，然后可以将其添加到两个页面组件中:

```
$ touch resources/assets/js/route-mixin.js
```

同时，让我们通过删除重复的`next`函数调用来改进代码。为此，我们将创建一个新的方法`getData`，它将负责找出从哪里获取页面的正确数据，以及获取这些数据。请注意，这个方法将是异步的，因为它可能需要等待 AJAX 解析，所以它将返回一个 Promise，而不是一个实际值。这个承诺在导航守卫中被解决。

`resources/assets/js/route-mixin.js`:

```
import axios from 'axios';

function getData(to) {
  return new Promise((resolve) => {
    let serverData = JSON.parse(window.vuebnb_server_data);
    if (!serverData.path || to.path !== serverData.path) {
      axios.get(`/api${to.path}`).then(({ data }) => {
        resolve(data);
      });
    } else {
      resolve(serverData);
    }
  });
}

export default {
  beforeRouteEnter: (to, from, next) => {
    getData(to).then((data) => {
      next(component => component.assignData(data));
    });
  }
};
```

We don't need a polyfill for Promise as that is already supplied in the `Axios` library.

# 分配数据

您会注意到，在`next`回调中，我们在主题组件上调用了一个名为`assignData`的方法，将数据对象作为参数传递。我们需要在任何使用这个`mixin`的组件中实现`assignData`方法。我们这样做是为了在将数据应用到组件实例之前，组件可以处理数据(如果需要的话)。例如，`ListingPage`组件必须通过`populateAmenitiesAndPrices`助手功能处理数据。

`resources/assets/components/ListingPage.vue`:

```
...

import routeMixin from '../js/route-mixin';

export default {
  mixins: [ routeMixin ],
  data() {
    return {
      title: null,
      about: null,
      address: null,
      amenities: [],
      prices: [],
      images: []
    }
  },
  components: { ... },
  methods: {
    assignData({ listing }) {
      Object.assign(this.$data, populateAmenitiesAndPrices(listing));
    },
    openModal() {
      this.$refs.imagemodal.modalOpen = true;
    }
  }
}
```

我们还需要将`assignData`添加到`HomePage`组件中。

`resources/assets/components/HomePage.vue`:

```
<script>
  import { groupByCountry } from '../js/helpers';
  import ListingSummary from './ListingSummary.vue';

  import axios from 'axios';
  import routeMixin from '../js/route-mixin';

  export default {
    mixins: [ routeMixin ],
    data() { ... },
    methods: {
      assignData({ listings }) {
        this.listing_groups = groupByCountry(listings);
      },
    },
    components: { ... }
  }
</script>
```

# 链接到列表页面

以上应该可以工作，但我们不能测试它，因为还没有任何应用内链接到列表页面！

我们的每个`ListingSummary`实例代表一个列表，因此应该是指向该列表页面的可点击链接。让我们使用`RouterLink`组件来实现这一点。请注意，我们绑定到`to`道具的对象包括路线的名称以及`params`对象，该对象包括路线动态段的值，即列表标识。

`resources/assets/components/ListingSummary.vue`:

```
<div class="listing-summary">
  <router-link :to="{ name: 'listing', params: { listing: listing.id } }">
    <div class="wrapper">
      <div class="thumbnail" :style="backgroundImageStyle"></div>
      <div class="info title">
        <span>{{ listing.price_per_night }}</span>
        <span>{{ listing.title }}</span>
      </div>
      <div class="info address">{{ listing.address }}</div>
    </div>
  </router-link>
</div>
```

完成后，列表摘要现在将成为链接。点击其中一个进入列表页面，我们会看到:

![](assets/47a777b4-a997-42b3-bf6b-5e8d34379b22.png)

Figure 7.15\. Successful AJAX call after navigating to listing page

我们可以在*图 7.15* 中看到，对清单 API 的 AJAX 调用是成功的，并且返回了我们想要的数据。如果我们也查看 Vue 开发工具选项卡，以及开发工具控制台，我们可以在组件实例中看到正确的数据。问题是我们现在有一个头图像的未处理的 404 错误:

![](assets/99a48262-9bff-432f-8679-3a846aca5295.png)

Figure 7.16\. Dev Tools console showing error

原因是组件的第一次渲染发生在调用`next`钩子中的回调之前*。这意味着在第一次渲染中使用组件数据的初始值。*

`resources/assets/components/ListingPage.vue`:

```
data() {
  return {
    title: null,
    about: null,
    address: null,
    amenities: [],
    prices: [],
    images: []
  }
},
```

在`HeaderImage`声明中，我们这样绑定第一个图像:`:image-url="images[0]"`。由于数组最初是空的，这将是一个未定义的值，并导致未处理的错误。

解释很复杂，但修复很简单:只需在`header-image`上添加一个`v-if`，确保在有效数据可用之前不会渲染。

`resources/assets/components/ListingPage.vue`:

```
<header-image 
  v-if="images[0]" 
  :image-url="images[0]" 
  @header-clicked="openModal"
></header-image>
```

# 滚动行为

浏览器自动管理的网站导航的另一个方面是*滚动行为*。例如，如果您滚动到页面底部，然后导航到新页面，滚动位置将被重置。但是如果您返回到上一页，浏览器会记住滚动位置，然后您会回到底部。

当我们用 Vue Router 劫持导航时，浏览器无法做到这一点。因此，当您滚动到 Vuebnb 主页的底部并单击古巴的列表时，假设加载列表页面组件时滚动位置不变。这对于用户来说感觉很不自然，他们希望被带到新页面的顶部:

![](assets/19966550-9244-468a-b9fa-2115b5b294bf.png)

Figure 7.17\. Scroll position issue after navigating with Vue Router

Vue Router 有一个`scrollbehavior`方法，当你改变路线时，只需定义水平和垂直滚动条的`x`和`y`位置，就可以调整页面的滚动位置。为了保持它的简单性，同时也为了保持 UX 的自然性，让我们这样做吧，这样当一个新页面被加载时，我们总是在页面的顶部。

`resources/assets/js/router.js`:

```
export default new VueRouter({
  mode: 'history',
  routes: [ ... ],
  scrollBehavior (to, from, savedPosition) {
    return { x: 0, y: 0 }
  }
});
```

# 添加页脚

为了改进 Vuebnb 的设计，让我们在每页的底部添加一个页脚。我们将使它成为一个可重用的组件，所以让我们从创建它开始:

```
$ touch resources/assets/components/CustomFooter.vue
```

这是标记。目前，它只是一个无状态组件。

`resources/assets/js/CustomFooter.vue`:

```
<template>
  <div id="footer">
    <div class="hr"></div>
    <div class="container">
      <p>
        <img class="icon" src="/images/logo_grey.png">
        <span>
          <strong>Vuebnb</strong>. A full-stack Vue.js and Laravel demo app
        </span>
      </p>
    </div>
  </div>
</template>
<style>
  #footer {
    margin-bottom: 3em;
  }

  #footer .icon {
    height: 23px;
    display: inline-block;
    margin-bottom: -6px;
  }

  .hr {
    border-bottom: 1px solid #dbdbdb;
    margin: 3em 0;
  }

  #footer p {
    font-size</span>: 15px;
    color: #767676 !important;
    display: flex;
  }
  #footer p img {
    padding-right: 6px;
  }
</style>
```

让我们将页脚添加到`App`组件中，就在输出页面的`RouterView`下方。

`resources/assets/js/App.vue`:

```
<template>
  <div>
    <div id="toolbar">...</div>
    <router-view></router-view>
    <custom-footer></custom-footer>
  </div>
</template>
<script>
  import CustomFooter from './CustomFooter.vue';

  export default {
    components: {
      CustomFooter
    }
  }
</script>
<style>...</style>
```

以下是它在列表页面上的外观:

![](assets/468a31ff-2de5-4199-8290-f4dc7e2085a3.png)

Figure 7.18\. Custom footer on listing page

这是它在主页上的样子。它看起来不太好，因为文本没有像您预期的那样向左对齐。这是因为此页面上使用的容器约束不同于我们添加到页脚的`.container`类:

![](assets/83c646d8-8f4f-493b-a19c-7376abe3cb57.png)

Figure 7.19\. Custom footer on home page

其实`.container`是专门为列表页面设计的，而`.home-container`是为首页设计的。为了解决这个问题，并使事情不那么混乱，让我们首先将`.container`类重命名为`.listing-container`。您还需要更新`ListingPage`组件，以确保它使用这个新的类名。

其次，让我们也将`.home-container`移动到主 CSS 文件，因为我们也将开始全局使用它。

`resources/assets/css/style.css`:

```
.listing-container {
  margin: 0 auto;
  padding: 0 12px;
}

@media (min-width: 744px) {
  .listing-container {
    width: 696px;
  }
}

.home-container {
  margin: 0 auto;
  padding: 0 25px;
}

@media (min-width: 1131px) {
  .home-container {
    width: 1080px;
  }
}
```

现在我们有`.home-container`和`.listing-container`作为我们的`custom-footer`组件的两个可能的容器。让我们根据路线动态选择类，这样页脚总是正确对齐的。

# 路线对象

*路线对象*代表当前活动路线的状态，可在根实例或组件实例内访问，如`this.$route`。此对象包含当前网址的解析信息和与该网址匹配的路由记录:

```
created() {
  console.log(this.$route.fullPath); // /listing/1
  console.log(this.$route.params); // { listing: "1" }
}
```

# 动态选择容器类

为了在`custom-footer`中选择正确的容器类，我们可以从 route 对象中获取当前路由的名称，并在模板文字中使用它。

`resources/assets/components/CustomFooter.vue`:

```
<template>
  <div id="footer">
    <div class="hr"></div>
    <div :class="containerClass">
      <p>...</p>
    </div>
  </div>
</template>
<script>
  export default {
    computed: {
      containerClass() {
        // this.$route.name is either 'home' or 'listing'
        return `${this.$route.name}-container`;
      }
    }
  }
</script>
<style>...</style> 
```

现在页脚在首页显示时将使用`.home-container`:

![](assets/efd60af9-5efc-4b8d-9c39-dd6e099f6ea5.png)

Figure 7.20\. Custom footer on home page with the correct container class

# 列表摘要图像滑块

在我们的主页上，我们需要使用户能够看到每个国家的 10 个可能列表中的三个以上。为此，我们将把每个列表摘要组变成一个图像滑块。

让我们创建一个新组件来容纳每个列表摘要组。然后，我们将在这个组件的侧面添加箭头，允许用户轻松地浏览它的列表:

```
$ touch resources/assets/components/ListingSummaryGroup.vue
```

我们现在将把显示列表摘要的标记和逻辑从`HomePage`抽象到这个新组件中。每个组都需要知道国家的名称和包含的列表，所以我们将添加这些数据作为道具。

`resources/assets/components/ListingSummaryGroup.vue`:

```
<template>
  <div class="listing-summary-group">
    <h1>Places in {{ country }}</h1>
    <div class="listing-summaries">
      <listing-summary
        v-for="listing in listings"
        :key="listing.id"
        :listing="listing"
      ></listing-summary>
    </div>
  </div>
</template>
<script>
  import ListingSummary from './ListingSummary.vue';

  export default {
    props: [ 'country', 'listings' ],
    components: {
      ListingSummary
    }
  }
</script>
<style>
  .listing-summary-group {
    padding-bottom: 20px;
  }

  .listing-summaries {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    overflow: hidden;
  }
  .listing-summaries > .listing-summary {
    margin-right: 15px;
  }

  .listing-summaries > .listing-summary:last-child {
    margin-right: 0;
  }
</style>
```

回到`HomePage`，我们将用一个`v-for`来声明`ListingSummaryGroup`，迭代每个国家组。

`resources/assets/components/HomePage.vue`:

```
<template>
  <div class="home-container">
    <listing-summary-group
      v-for="(group, country) in listing_groups"
      :key="country"
      :listings="group"
      :country="country"
      class="listing-summary-group"
    ></listing-summary-group>
  </div>
</template>
<script>
  import routeMixin from '../js/route-mixin';
  import ListingSummaryGroup from './ListingSummaryGroup.vue';
  import { groupByCountry } from '../js/helpers';

  export default {
    mixins: [ routeMixin ],
    data() {
      return {
        listing_groups: []
      };
    },
    methods: {
      assignData({ listings }) {
        this.listing_groups = groupByCountry(listings);
      }
    },
    components: {
      ListingSummaryGroup
    }
  }
</script>
```

Most developers will use the terms *image carousel* and *image slider* interchangeably. In this book, I make a slight distinction, a *carousel* contains a single image that gets completely switched out with another, while a *slider* shifts the position of images, with several visible at once.

# 添加滑块

我们现在将滑块功能添加到`ListingSummaryGroup`。为此，我们将重用我们在[第 6 章](06.html)、*中用 Vue.js 组件*构建小部件时制作的`CarouselControl`组件。我们希望在组的两侧显示一个，所以让我们将它们放入模板，记住声明`dir`属性。我们还将添加一些结构标记和 CSS 来显示控件。

`resources/assets/components/ListingSummaryGroup.vue`:

```
<template>
  <div class="listing-summary-group">
    <h1>Places in {{ country }}</h1>
    <div class="listing-carousel">
      <div class="controls">
        <carousel-control dir="left"></carousel-control>
        <carousel-control dir="right"></carousel-control>
      </div>
      <div class="listing-summaries-wrapper">
        <div class="listing-summaries">
          <listing-summary
            v-for="listing in listings"
            :listing="listing"
            :key="listing.id"
          ></listing-summary>
        </div>
      </div>
    </div>
  </div>
</template>
<script>
  import ListingSummary from './ListingSummary.vue';
  import CarouselControl from './CarouselControl.vue';

  export default {
    props: [ 'country', 'listings' ],
    components: {
      ListingSummary,
      CarouselControl
    }
  }
</script>
<style>
...

.listing-carousel {
  position: relative;
}

.listing-carousel .controls {
  display: flex;
  justify-content: space-between;
  position: absolute;
  top: calc(50% - 45px);
  left: -45px;
  width: calc(100% + 90px);
}

.listing-carousel .controls .carousel-control{
  color: #c5c5c5;
  font-size: 1.5rem;
  cursor: pointer;
}

.listing-summaries-wrapper {
  overflow: hidden;
}
</style>
```

添加此代码后，您的主页将如下所示:

![](assets/0c9de4a0-ed44-4cdf-882d-947ab738a935.png)

Figure 7.21\. Carousel controls on listing summary groups

# 翻译

为了响应轮播控件被点击而移动我们的列表摘要，我们将使用一个名为`translate`的 CSS 转换。这会将受影响的元素从其当前位置移动以像素为单位指定的量。

每个列表摘要的总宽度为 365px (350px 固定宽度加上 15px 边距)。这意味着如果我们将我们的组向左移动 365 像素，它会产生将所有图像的位置移动一个的效果。您可以在这里看到，我添加了翻译为内联样式来测试它是否有效。请注意，我们`translate`在*负*方向让该组向左移动:

![](assets/a7557439-4548-4a23-b2ff-86f078053d9a.png)

Figure 7.22\. Listing group shifted to the left by using translate

通过用`listing-summary`类将内联样式绑定到元素，我们可以控制从 JavaScript 的翻译。让我们通过一个计算属性来实现这一点，这样我们就可以动态计算翻译量。

`resources/assets/components/ListingSummaryGroup.vue`:

```
<template>
  <div class="listing-summary-group">
    <h1>Places in {{ country }}</h1>
    <div class="listing-carousel">
      <div class="controls">...</div>
      <div class="listing-summaries" :style="style">
        <listing-summary...>...</listing-summary>
      </div>
    </div>
  </div>
</template>
<script>
  export default {
    props: [ 'country', 'listings' ],
    computed: {
      style() {
        return { transform: `translateX(-365px)` }
      }
    },
    components: { ... }
  }
</script>
```

现在，我们所有的汇总组都将被转移:

![](assets/07cfeef2-c95f-4f4b-9939-85058fb8b98f.png)

Figure 7.23\. Shifted listing groups with translate controlled by JavaScript

*图 7.23* 中明显的问题是，我们一次只能看到三个图像，它们从容器溢出到页面的其他部分。

为了解决这个问题，我们将把 CSS 规则`overflow: hidden`从`listing-summaries`移到`listing-summaries-wrapper`。

`resources/assets/components/ListingSummaryGroup.vue`:

```
...

.listing-summaries-wrapper {
  overflow: hidden;
}

.listing-summaries {
  display: flex;
  flex-direction: row;
  justify-content: space-between;  
}

...
```

# 转盘控件

我们现在需要转盘控件来改变翻译的值。为此，让我们向`ListingSummaryGroup`添加一个数据属性`offset`。这将跟踪我们移动了多少图像，也就是说，它将从零开始，最多到七(不是 10，因为我们不想移动得太远，以至于所有图像都在屏幕之外)。

我们还将添加一个方法`change`，它将作为转盘控件组件发出的自定义事件的事件处理函数。该方法接受一个参数`val`，该参数可以是`-1`或`1`，具体取决于左侧或右侧转盘控件是否被触发。

`change`将步进`offset`的值，然后乘以每个列表的宽度(365px)来计算平移。

`resources/assets/components/ListingSummaryGroup.vue`:

```
...

const rowSize = 3;
const listingSummaryWidth = 365;

export default {
  props: [ 'country', 'listings' ],
  data() {
    return {
      offset: 0   
    }
  },
  methods: {
    change(val) {
      let newVal = this.offset + parseInt(val);
      if (newVal >= 0 && newVal <= this.listings.length - rowSize) {
        this.offset = newVal;
      }
    }
  },
  computed: {
    style() {
      return { 
        transform: `translateX(${this.offset * -listingSummaryWidth}px)` 
      }
    }
  },
  components: { ... }
}
```

最后，我们必须在模板中使用`v-on`指令为`CarouselControl`组件的`change-image`事件注册一个监听器。

`resources/assets/components/ListingSummaryGroup.vue`:

```
<div class="controls">
  <carousel-control dir="left" @change-image="change"></carousel-control>
```

```
  <carousel-control dir="right" @change-image="change"></carousel-control>
</div>
```

完成后，我们为每个列表组提供了一个工作图像滑块！

# 收尾

还有两个小功能可以添加到这些图像滑块中，为 Vuebnb 用户提供最佳体验。首先，让我们添加一个 CSS 过渡来动画化半秒钟的平移变化，并给出一个不错的*滑动*效果。

`resources/assets/components/ListingSummaryGroup.vue`:

```
.listing-summaries {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  transition: transform 0.5s;
}
```

可悲的是，你在一本书里看不到这种效果，所以你必须自己尝试一下！

最后，与我们的图像转盘不同，这些滑块不是连续的；它们有一个最小值和最大值。如果达到最小值或最大值，让我们隐藏适当的箭头。例如，当滑块加载时，左箭头应该隐藏，因为用户不能将偏移量进一步减少到零以下。

为此，我们将使用样式绑定来动态添加一个`visibility: hidden` CSS 规则。

`resources/assets/components/ListingSummaryGroup.vue`:

```
<div class="controls">
  <carousel-control 
    dir="left" 
    @change-image="change" 
    :style="leftArrowStyle"
  ></carousel-control>
  <carousel-control 
    dir="right" 
    @change-image="change" 
    :style="rightArrowStyle"
  ></carousel-control>
</div>
```

和计算属性。

`resources/assets/components/ListingSummaryGroup.vue`:

```
computed: {
  ...
  leftArrowStyle() {
    return { visibility: (this.offset > 0 ? 'visible' : 'hidden') }
  },
  rightArrowStyle() {
    return { 
      visibility: (
        this.offset < (this.listings.length - rowSize) 
        ? 'visible' : 'hidden'
      ) 
    }
  }
}
```

完成后，我们可以看到页面加载时左箭头被隐藏，正如预期的那样:

![](assets/6797f901-bc01-4b74-bf89-cc6e085eaa9a.png)

Figure 7.24\. Hidden left arrow on page load

# 摘要

在本章中，我们学习了路由器库是如何工作的，以及为什么它们是 SPa 的重要补充。然后我们熟悉了 Vue Router 的关键特性，包括路由对象、导航守卫以及`RouterLink`和`RouterView`特殊组件。

将这些知识应用到实践中，我们安装了 Vue Router，并将其配置为在我们的应用程序中使用。然后我们为 Vuebnb 建立了一个主页，包括一个在图像滑块中组织的列表摘要的图库。

最后，我们实现了一个架构，用于将页面与可用的本地数据或通过 AJAX 从 web 服务检索的新数据正确匹配。

现在，我们的应用程序中有大量组件，其中许多组件相互之间传递数据，现在是时候研究另一个关键的 Vue.js 工具:Vuex 了。Vuex 是一个基于 Flux 的库，它提供了一种管理应用程序状态的高级方法。